\sommairefr{It has always been a marvel to me---that French language;
  it has always been a puzzle to me. How beautiful that language is!
  How expressive it seems to be! And when it comes from lips like
  those of Sarah Bernhardt, how eloquent and limpid it is!  And, oh, I
  am always deceived---I always think I am going to understand
  it}{Mark Twain}

\section*{Introduction}
Les ordinateurs sont devenus plus petits, plus puissants et plus
fiables; des avances qui ont donné naissance aux utilisations
d'ordinateurs qui était inimaginable il y a même quelques
décennées. L'ordinateur, qui, à l'origine a été conçu et construit en
tant qu'un résolutionneur d'équations, se trouve aujourd'hui faire des
tâches très divers et variées. La société elle-même est devenue plus
exigeante au niveau téchnologique, au point que
``l'ordinateurisation'' est un moyen nécessaire pour répondre à ses
attentes. Les exemples de cette omnipresence d'ordinateurs incluent
les freins anti-verouillage, les machines à laver automatique ainsi
que les téléphones portables et montres-bracelets qui ont plus de
capacités de calculs que des super-calculatrices d'il y a 20 ans.

En fait, selon les estimations d'industrie, parmi les six
\emph{milliards} de processeurs fabriqué par année, 90-98\% sont
embarqués et donc invisibles. Les utilisations perçues majeures des
ordinateurs actuellement se trouvent être les suivantes:\\

\begin{itemize}
\item{Les bases de données;}
\item{Le calcul scientifique;}
\item{Les applications financières;}
\item{Le bureautique;}
\item{La communication via les courriéls, les messageries instantanées et
  du réseau sociale;}
\item{La rédaction, tel les livres ainsi que les journaux et revues
  etc.;}
\item{Le divertissement, tel le lecture des films, les jeux vidéos
  etc.}
\end{itemize}

\subsection*{Les systèmes temps-réels}
Parmi d'autres usages d'ordinateur à nos jours, il y a aussi celle des
systèmes temps-réels. Qu'est-ce un système temps-réel? Brièvement,
c'est un système ou un paradigme ou une situation où la validité du
résultat d'un calcul dépend aussi fortement sur le \emph{moment où ce
  résultat soit disponible} ainsi que sur le valeur du résultat. Le
moment dans le temps jusqu'où les résultats doivent êtres disponibles
est appelé le ``deadline''--soit le délai---pour ce calcul. Les
utilisations importantes des systèmes temps-réels sont:\\

\begin{itemize}
\item{Contrôle de processus industriel;}
\item{Contrôle de plate-forme mobiles ou des véhicules (aussi appelé
  l'automatique);}
\item{Surveillance d'état de véhicules et des capteurs comme des GPS
  et des systèmes de contrôle de mission dans les avions;}
\item{Multimédia comme les lecteurs de vidéos.}
\end{itemize}

Des systèmes temps-réels peuvent être découpés en deux catégories;
chacune desquelles dépends de la validité des résultats d'un calcul
après son deadline. Les systèmes ``temps-réels durs'' sont ceux dans
lesquels la validité des résultats après le deadline sont totalement
invalides; tandis que les systèmes ``temps-réels mous'' sont ceux dans
lesquels la validité des résultats décroît d'une manière plus lente
après le deadline. Figure~\ref{fig:classification_systemes} montre la
validité des résultats dans des systèmes temps-réels en fonction du
temps.

\begin{figure}
\centering
\includegraphics{figs/hard_vs_soft}
\caption{\`A gauche: la validité des résultats d'un système temps-réel
  dur. \`A droite: la validité des résultats d'un système temps-réel
  mous.}
\label{fig:classification_systemes}
\end{figure}

La naissance des systèmes temps-réels se trace jusqu'à l'article
séminale de Leyland et Liu sur l'ordonnançabilité des tâches
temps-réels~\cite{liu@jacm73}. Cette article a introduit l'affectation
``Rate Monotonic'' pour les priorités des tâches temps-réels qui donne
un ordonnance faisable si elle existe, ainsi que la technique
d'analyse pour déterminer si l'ensemble de tâches donné est
ordonnançable.

La dichotomie déjà présentée nécessite un peu de clarification et
caractérisation. Certaines applications temps-réels peuvent êtres
construites à partir seulement des ``timers'' de haute résolution; un
exemple typique de ce type de système est une machine à laver
automatique avec plusieurs type et nombre de cycles. Au démarrage de
chaque cycle, un timer qui correspond à sa durée est armé; à l'arrivée
de ce dernier, le cycle est terminé et le prochain commence---sauf à
la fin du dernier cycle.

Au deuxième extrême de complexité de systèmes sont, par exemple, des
systèmes automatique; ceux qui contrôle un plate-forme mobile tel un
avion ou une voiture. Ce type de système nécessite une sophistication
de support d'exécution sous-jacente qui dépasse largement les simples
``timers''. Ici sont nécessaires des tâches cyclique, qui sont
déclenchées régulièrement et fiablement par un système d'exploitation
robuste qui assure que les délais de déclenchement sont inférieures à
une certaine borne bien établie et déterminée.

Finalement, il y a des systèmes qui sont un mélange des deux types
déjà présenté. Ces systèmes contiennent---typiquement---une mélange
des tâches cycliques (qui sont la plupart dures) ainsi que des tâches
\emph{apériodique} (qui sont la plupart mouches). Les exemples de ces
systèmes sont des ``mission management systems'' sur des avions, des
radars, et ``assembly lines''.

\subsection*{Logiciel haute intégrité et la certification}
\`A cause de la sophistication augmentant des systèmes automatiques,
la seule manière de les manipuler, manoeuvrer et surveiller
correctement se trouve être mettre un ordinateur dans le boucle de
contrôle. L'ordinateur peut stabiliser des plates-formes qui sont de
nature instables et dans le cas de système de surveillance, peut
présenter une image synthétisée et précise de la situation. Due à
cette ordinateurisation des systèmes qui contrôle des voitures, avions
et trains etc., une faute dans leurs logiciels peut résulter
directement en perte de vies humaines. Ce genre de logiciels sont
appelées des logiciels de ``haute intégrité'', où une faute peut
engendrer la perte de vie humaine (avions, voiture etc.) ou la perte
d'une mission (satellites, sondes, lanceurs etc.). \`A cause d'impacts
sévères de fautes dans ces systèmes, les organes gouvernementales
certifient des logiciels qui peuvent être mises à bords de ses
plates-formes. Dans le cas de l'avionique, spécifiquement, c'est le
FAA et EUROCAE qui certifient les logiciels, et le standard pour
certifier les logiciels avioniques s'appelle ``DO-178B, Software
Considerations in Airborne Systems and Equipment
Certification''~\cite{do178b}. Cette certification augmente
significativement le prix du logiciel, qui augmente le prix du produit
totale. Donc, une approche quiconque pour réduire le prix de la
certification est toujours utile au domaine.

\subsection*{Ingénierie Dirigée par les Modèles}
Un modèle est une abstraction ou approximation d'un système. Cette
abstraction, par sa nature même, se donne plus facilement à
l'analyse. Il est aussi plus facile de créer le modèle que de créer
directement le système à la main. Les modèles existent dans d'autres
domaines de la science depuis des siècles; l'exemple archétypique d'un
modèle est l'ensemble d'équations qui approximent le trajectoire d'un
projectile. De même, Ingénierie Dirigée par les Modèles (IDM),
Développement Dirigé par les Modèles (DDM) et d'autres alias sont
utilisés pour les approches de développement du logiciel
où~\cite{france@fose07}:

\begin{quote}
``models are the primary artifacts of development and developers rely
  on computer-based technologies to transform models to running
  systems''
\end{quote}

L'IDM a vraiment décollé comme technique pendant les années 1990s avec
la formation de l'``Object Management Group'' et la standardisation
d'UML (Unified Modeling Language)~\cite{uml-super}, qui reste toujours
le langage de modélisation le plus répandu. Avant l'UML, il existaient
d'autres langages de modélisation aussi. En général, en informatique,
les modèles servent une ou plusieurs des buts suivantes:

\begin{itemize}
\item{De la documentation;}
\item{De l'analyse;}
\item{De la génération du code.}
\end{itemize}

Le cycle de développement---comme promu par l'IDM et spécifiquement
dans le cadre de OMG+UML---est montré dans la
Figure~\ref{fig:idm_processus}. Après la capture d'exigences, un désign
préliminaire est construit, qui est raffiné au fur et sur mesure pour
avoir des désigns progressivement plus détaillés. \`A chaque étape de
cette raffinement, des analyses différentes peuvent être appliquées au
modèle. Au moment ou le désign est assez détaillé, le code qui
correspond peut être généré et simulé. Suite aux simulations, des
modifications peuvent être apportées au code.

\begin{figure}
\centering
\includegraphics[scale=1.0]{figs/mde_chain}
\caption{Les étapes typique du processus de développement IDM}
\label{fig:idm_processus}
\end{figure}

\subsection*{Contexte et survole du travail}
Étant donné la complexité des systèmes temps-réels ainsi que leurs
criticité, ça devient infaisable, si ne pas impossible, de les écrire
totalement à la main. \`A cette fin, il y a plusieurs approches plus
ou moins IDM o\`u le design du système est donné dans un langage de
haut niveau et des outils aident en générant automatiquement du code
source correspondant. Dans la section suivante, un survole de
différentes méthodes et langages de haut niveau sera donné. Cette
génération du code est toujours conçue pour un ``couple'',
c'est-à-dire, le langage de haut niveau qui est le source, et le
langage de programmation qui est le cible de cette opération.

Il existe un besoin pour avoir un ``couple'' de langage source qui est
un ADL spécifique au domaine (avionique, temp-réel dûr, \ldots) ainsi
qu'un langage et exécutif cible qui est spécifique au domaine. Ce
couple a été identifié comme le langage AADL en tant que source et le
profil Ravenscar d'Ada 2005 comme langage
cible~\cite{burns@adalett04}, avec l'Open Ravenscar Kernel
(ORK)~\cite{puente@ae00} comme l'exécutif.

Pourquoi existe ce besoin et à quoi ça sert \emph{exactement}
d'introduire encore une nouvelle couche d'abstraction dans les
processus de développement des systèmes de haute criticité? Comme déjà
dit, les systèmes à haute criticité doivent être certifiés par les
organes gouvernementales. L'avionique est certifiée selon un standard
appelé le ``Software Considerations in Airborne Systems and Equipment
Certification'', ou DO-178B~\cite{do178b}. Selon les estimations
d'industrie, suivre ce standard peut rajouter de 50\% à 100\% à la
prix d'un projet. En vue de ça, la Commission Européenne a commencé le
projet ASSERT\footnote{\url{http://www.assert-online.org}}, qui a
comme but de créer de nouvelles méthodes et approches pour développer
les systèmes avioniques et spatiales. L'une des approches à investiger
est celle du couple AADL+Ada Ravenscar, qui pourrais potentiellement
réduire le prix de ce genre de logiciel. La réduction du temps de
développement est claire, car quand nous écrivons dans un langage plus
abstrait et convertis automatiquement au code, ça fait gagner du
temps. Aussi, si la générateur du code lui-même se trouve être
certifié, le code généré pourrais être exonéré du processus chèr et
coûteux (en temps et argent) de la certification.

Le travail achevé et présenté dans cette thèse consiste principalement
en règles de génération du code haute intégrité Ada depuis le langage
AADL et un générateur du code qui implémente ces règles. Le code
généré est dans la forme d'un cadre d'exécution, qui fournit les
entités d'exécution nécessaires et bien dimensionnées pour
l'architecture comme décrit. Ces entités d'exécution consiste en
(entre autres choses) les threads, les tampons d'échange de messages
entre ces threads, les mécanisms d'envoi d'évènements et les APIs
générés pour accéder facilement à tous ces artefacts. Ce cadre
d'exécution et ensuite rempli par les caractéristiques fonctionnelle
des threads (sous formes de ``callbacks''), qui complète le système.

Aussi présenté est une solution élégante au problème---venant du
domaine d'automatisme, qui est fortement lié au domaine sous
considération---de la communication déterministe entre différents
threads. La solution présentée est aussi intégrée dans l'outillage
développé pour fournir un toolkit qui répond aux besoins
d'automatisme. Une vérification formelle de la validité de la solution
au problème de communication déterministe utilisant l'algèbre de
processus LOTOS~\cite{bolognesi@cnis87, logrippo@cnis92,
  garavel@cav07} est présentée, ainsi que l'intégration de sa
génération automatique avec l'outillage développé.

Une sémantique formelle du code généré est présentée, sous forme d'une
sémantique structurée opérationnelle (SOS pour Structured Operational
Semantics). Cette sémantique permet de raisonner d'une manière
mathématiquement rigoureuse sur le code généré. Dans le futur, cette
sémantique pourrais donner naissance aux simulateurs précis ainsi
qu'une vérification systémique de ces systèmes.

\section*{État de l'art}
Comme déjà constaté, les systèmes temps-réels ne sont pas nouveaux, et
donc ne sont pas nouveaux les approches pour les implémenter. Leyland
et Liu ont donné la première analyse rigoureuse de l'ordonnonçabilité
d'un ensemble des tâches temps-réels~\cite{liu@jacm73}. Mais le
concept d'une tâches temp-réel en tant qu'une unité d'exécution
distincte et (quasi)-indépendante a été présenté par Manacher bien
avant~\cite{manacher@jacm67}.

\subsection*{Les tâches---ou threads---temps-réels}
Nous définissons---dans le contexte de cette thèse---une tâche
temp-réel comme étant une fonctionnalité ou séquence d'actions qui
devraient être prise par le système, et ça sous des contraintes et
propriétés temporelle précises. Les tâches temps-réels sont quasiment
toujours récurrentes, c'est-à-dire, elles se répètent toute au long de
la vie du système.

Il y a deux types majeures de tâches temps-réels; celles qui sont
\emph{cyclique} (ou \emph{périodique}) et celles qui ne le sont pas
(nous les appelons aussi \emph{apériodique}). Des tâches cycliques
sont celles qui sont déclenchées aux intervalles régulières, que nous
appelons leur \emph{période}. Normalement les tâches périodiques sont
des tâches dures dans un systèmes---soit disant, elles ne doivent pas
rater leurs délais. Elles sont utilisées pour des boucles de contrôle,
pour lire les données depuis les capteurs, pour mettre à jour
périodiquement les écrans des systèmes tels que les GPS etc.

La deuxième type sont des tâches apériodiques, celles qui sont
déclenchées en réception d'un événement, que ça soit généré par
l'environnement (événement externe) ou par une autre tâche
(événement interne). Ces tâches peuvent être mous ou dures. Il y a
une version plus robuste de ces tâches qui s'appellent les tâches
sporadiques, celles-là sont déclenchées par la réception d'un
événement mais elles enforcent aussi une séparation minimale entre
deux déclenchement de la même tâche, et donc ne peuvent pas surcharger
le système au cas de ``rafale d'événement''.

\subsection*{L'ordonnancement}
L'ordonnancement des tâches temps-réels est une des activités les plus
importantes dans un tel système. L'ordonnancement dénote la
séquencement des différentes tâches dans le système. Dans un système
temp-réel, l'ordonnanceur doit tenir compte de différentes contraintes
temporelles des tâches impliquées et prendre des décisions qui
garantissent le moindre de rates de délais des tâches.

Il y a plusieurs types d'ordonnanceurs temps-réels, nous nous
concentrons ici sur l'ordonnanceur préemptif aux priorités fixes (FPPS
pour Fixed Priority Preemptive Scheduler), car c'est très répandu et
c'est l'ordonnanceur stipulé par le Profil Ravenscar. Simplement, un
ordonnanceur FPPS implique qu'une tâche peut être préemptée (et son
état sauvegardé pour la remettre en marche exactement au même endroit
dans le futur), et que les priorités de tâches sont statiques et fixes
pendant la vie du système. Aussi, un FPPS implique qu'à n'importe quel
moment donné, la tâche la plus prioritaire qui est ``prête'' est celle
qui est sur le processeur (bien sur au cas ou il y a un seul
processeur).

Étant donné un ensemble de tâches et leurs caractéristiques
temporelles tels que le fait qu'une tâche est périodique ou pas, sa
période, sa délai etc.; et étant donné le fait que l'ordonnanceur sur
lequel cet ensemble de tâches va tourner est un FPPS, il existe un
teste extrêmement simple pour déterminer si ledit ensemble est
ordonnançable. Cependant il ne faut pas oublier que---la version
basique de---ce teste est applicable seulement aux tâches
indépendantes: celles qui ne se communiquent ni ne se synchronisent
pas entre elles.

\subsection*{Les approches d'Ingénierie Dirigé par les Modèles}
Comme déjà indiqué, il y a plusieurs techniques de développement de
logiciel basé sur les modèles, dont aussi celles qui sont utilisées
pour les systèmes temps-réels et/ou critiques. La suite donne des
petites introductions aux plus importantes parmi celles-ci.

\subsubsection*{Lustre et SCADE Suite}
Lustre est un langage fonctionnelle pour modéliser des systèmes
réactifs et synchrone en tant que flux de données qui est pertinent
aux systèmes réactifs; dont principalement des systèmes
automatiques~\cite{halbwachs@popl87, halbwachs@ieee91}. Industrialisé
par Esterel Technologies, son générateur du code est certifié jusqu'au
niveau ``A'' du standard DO-178B. Dans le spectre des langages, Lustre
est synchrone: il est considéré qu'il y a une résolution minimale
d'activité du système, au-delà duquel n'est pas possible une fréquence
d'évènements. Cette hypothèse permet de générer du code déterministe
et qui ne repose pas nécessairement sur un certain système
d'exploitation ou un autre; et ça puisque le choix logique
d'implémenter un programme synchrone se trouve être un exécutif
cyclique.

Comme déjà dit, Lustre implémente un paradigme de flux de données;
chaque \emph{noeud} d'un programme définit les traitement sur ses flux
``entrants'' qui transforment ces valeurs et les transmettent en tant
que flux ``sortants''. Ces flux sont, en Lustre, représentés par des
paramètres de ces noeuds. Les avantages qu'apporte Lustre sont
nombreuses:

\begin{itemize}
\item{C'est un langage mathématiquement définit qui est très aligné à
  l'automatisme;}
\item{C'est facile à apprendre et fournit une exécution robuste et
totalement déterministe;}
\item{Il fournit des abstractions très proche aux concepts natifs de
l'automatisme;}
\item{Car le code Lustre est représenté comme un automate, on peut appliqué
du ``model-checking'' sur des modèles Lustre, et fournir de la vérification;}
\item{Avec SCADE Suite (la version commercialisée par Esterel Technologies),
il y a la possibilité de générer directement du code C certifié
jusqu'au niveau ``A'' de DO-178B.}
\end{itemize}

Ceci dit, il y a quand-même un certain nombre de désavantages associés
avec l'utilisation de Lustre et/ou SCADE Suite:

\begin{itemize}
\item{Le plus grand désavantage reste le fait que Lustre génère un
  programme synchrone qui doit tourner sur un exécutif
  cyclique. Donc toutes les tâches doivent être périodique;}
\item{Sa nature cyclique et synchrone engendre la perte de plusieurs
  cycles du processeur;}
\item{Ce n'est pas pratique pour programmer des systèmes temps-réels
  générique; c'est-à-dire ceux qui ne sont pas des systèmes
  automatiques.}
\end{itemize}

\subsubsection*{MATLAB \simu}
\simu est un ``add-on'' ou plugin pour MATLAB qui laisse modéliser les
systèmes hybrides en utilisant des symboles graphiques pour
représenter les transformations à apporter sur les données qui entrent
pour produire les données sortantes; assez similaire au Lustre. Le
plugin laisse générer aussi du code C en utilisant l'outil Real-Time
Workshop (RTW). RTW peut générer du code pour un nombre important
d'environnement cible, du système d'exploitation temps-réel complèxe
jusqu'aux exécutifs minimales. Le code généré par RTW peut \^{e}tre
mono-t\^ache, soit synchrone comme Lustre, ainsi que multi-t\^ache, ce
qui nécessite un RTOS sous-jacente.

Un autre avantage de Simulink est le fait qu'il nous laisse concevoir
le système en forme visuelle en utilisant des bloques hiérarchiques de
computation avec des ports qui peut être branchés pour communiquer
entre t\^aches. Figure~\ref{fig:abs_simulink_fr} est un exemplaire
d'un composant qui calcul la valeur absolue d'un entier. Chaque modèle
a une fréquence de base qui est la fréquence maximale d'ensemble de
t\^aches. Les autres bloques dans le système sont soit à la même
fréquence soit son multiple. Figure~\ref{fig:subsystem_simulink_fr}
est un exemplaire d'un sous-système utilisés comme un bloque
hierarchique dans un système englobant. Les ports d'entrées et sorties
deviennent les parametres formels dans le code généré.

\begin{figure}
\centering
\includegraphics[scale=0.5]{figs/abs_simulink}
\caption{Un modèle Simulink pour calculer la valeur absolue d'un
  entier}
\label{fig:abs_simulink_fr}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.5]{figs/abs_block_simulink}
\hspace{10mm}
\includegraphics[scale=0.5]{figs/subsystem_simulink}
\caption{Gauche: La logique de valeur absolue defini comme un
  sous-systéme.  \texttt{Abs\_In} et \texttt{Abs\_Out} sont les
  ports d'entrées et sorties. Droite: Le sous-système de valeur
  absolue utilisée dans un systéme, les ports sont connectées a
  une source et un scope}
\label{fig:subsystem_simulink_fr}
\end{figure}

Simulink est extrêmement répandu dans le domaine de
l'automatique. L'outillage existe qui peux même traduire ces
modèles~\cite{caspi@emsoft04} à Lustre~\cite{caspi@sigplan03}, ainsi
qu'à Z~\cite{arthan@icfem00}. Il a été utilisé dans l'industrie pour
concevoir le système d'atterrissage d'avions\footnote{Boeing X40A},
contrôle de vitesse vehiculaire\footnote{Camions Mercedez-Benz} et
freinage automatisé\footnote{Pacifica Group Technologies}.

\paragraph{Advantages de MATLAB Simulink}
\begin{itemize}
\item{Modélisation à haut niveau de systèmes automatiques;}
\item{Génération du code ciblé aux systèmes d'exploitations
  différents;}
\item{Bibliothèque importante de composants prédéfinis pour
  d'algorithmes standards d'automatique;}
\item{Génération du code synchrone ainsi qu'asynchrone, donc ciblé à
  un RTOS;}
\item{Simulation fourni la possibilité de déboggage au niveau du
  modèle.}
\end{itemize}

\paragraph{Désavantages de MATLAB Simulink}
\begin{itemize}
\item{Principalement pertinent aux systèmes automatiques;}
\item{Son avantage principale---étant près du domaine
  d'automatique---est aussi son désavantage principale. \`A cause de
  sa spécificité, ce n'est pas très doué au développement de systèmes
  temps-réels générales;}
\item{Comparé à SCADE, Simulink ne génére pas du code
  certifié DO-178B, donc le code doit être certifié
  indépendamment.}
\end{itemize}

\subsection*{Unified Modeling Language}
La version 2 d'Unified Modeling Language~\cite{uml-infra, uml-super},
soit UML2, est un langage de conception de logiciel standardisé par
l'Object Management Group (OMG). C'est principalement un langage
graphique pour la conception de logiciel orienté objet. L'OMG a
standardisé l'UML en utilisant le cadre de méta-modélisation
Meta-Object Facility~\cite{mof-std}, soit MOF. Un méta-modèle est le
modèle d'un modèle, car il décrit l'univers de tout les modèles
possible qui sont structurellement valides. Dans le domaine de
compilateurs, un méta-modèle est l'égale à une arbre de syntaxe
abstraite.

UML2 est un langage d'usage générale pour la conception de logiciel,
grâce auquel il compris un nombre important de type de diagrammes; il
y'en a pour de la documentation, de l'analyse, et finalement, de la
génération du code. Un diagramme de classes montre la relation entre
les classes dans le système sous étude, il montre la hiérarchie de
classes, les associations et la composition entre elles. De plus, la
diagramme de classe peux aussi montrer les détails de classes comme
méthodes, données et leurs attributs.

Figure~\ref{fig:class_diag_fr} montre l'exemple d'un contrôleur
automotive. La classe \texttt{RPM\_Controller}, qui est dérivée de
\texttt{Value\_Controller}. Les classes \texttt{RPM\_Controller} et
\texttt{Driver\_Input} sont ``actives'', c'est-à-dire, elles ont leurs
propres t\^aches d'exécution. Les deux ont d'associations à
\texttt{Driver\_Params}, qui représente un tampon partagé. Les autres
classes dans l'architecture représentent les composants d'accélération
et de freinage. Le code généré pour ce modèle résulterait en t\^aches
pour les deux classes actives, ainsi que le tampon partagé, les
méthodes et les données encapsulées par d'objets.

\begin{figure}
\centering
\includegraphics[scale=0.75]{figs/class_diag}
\caption{Un diagramme de classes avec les rélations de types
  differents en UML2, crée avec Rhapsody}
\label{fig:class_diag_fr}
\end{figure}

Le deuxième diagramme pertinent aux systèmes temps-réels est le
``statechart'', soit graphe d'état~\cite{jansamak@acsc04,
  allen@sigplan95}. Les statecharts sont les machines à états finies
attachées aux classes actives pour décrire leurs comportements. Les
statecharts sont un type d'automates étendus avec la capacité de
modifier les attributs de sa classe et d'envoyer les
\emph{signaux}---évènements asynchrones---aux autres classes
actives~\cite{lynch@concur01}. Figure~\ref{fig:statechart_fr} montre
une machine à état qui implémente un chauffage d'eau avec thermostat.

\begin{figure}
\centering
\includegraphics[scale=0.5]{figs/statechart}
\caption{Un diagramme de statechart d'UML2, attaché a une classes pour
  décrire sont comportement}
\label{fig:statechart_fr}
\end{figure}

Avec ces capacités, l'utilisation d'UML2 est répandu dans
l'industrie pour d'applications temps-réels. Les outils de conception
comme Rhapsody$\circledR$ fournis la génération du code, qui
réduit la durée de développement. Ceci dit, il y a plusieurs
désavantages d'UML2 dans les systèmes à haute intégrité.
\begin{comment}
Le langage est très large et complexe, ses sémantiques sont pas
définies formellement, ce qui laisse les outils choisir leurs
propres interprétations. Hors, le problème principale est que
l'UML2 n'est pas conçu pour les systèmes temps-réels, alors il n'y
a pas les concepts de priorité, de délai, le temps d'exécution
au pire cas.
\end{comment}

\paragraph{Avantages d'UML2}
\begin{itemize}
\item{Standardisé et très répandu dans l'industrie;}
\item{Proche du domaine de logiciel;}
\item{La modélisation orientée objet et l'intégration de
  comportement fonctionnel;}
\item{Les régles de génération du code sont naturels et
  intuitifs, surtout vers des langage comme C/C++.}
\end{itemize}

\paragraph{Désavantages d'UML2}
\begin{itemize}
\item{Le langage n'est pas conçu pour les systèmes temps-réels,
  alors il n'y a pas de concepts comme délai, priorité etc.;}
\item{Absence des sémantiques formelles, les comportements du code
  généré par d'outils différents ne sont pas les m\^emes;}
\item{Complexité de langage, le standard fais 2000 pages, avec 13
  types de diagrammes différents;}
\item{Couplage très fort avec la programmation orientée objet. Les
  systèmes temps-réels évitent l'orientation objet en faveur de
  temps d'exécution déterministe;}
\item{Utilisation de la \emph{surcharge sémantique} sur d'artefacts de
  bases pour énuméré de nouveaux concepts. Par exemple, une t\^ache en
  UML2 est représentée par une classe active, bien que ça ne soit pas
  une classe.}
\end{itemize}

\subsection*{HRT-HOOD, HRT-UML et MARTE UML}
Cette section regroupe plusieurs téchnologies et langages de
conception pour les systèmes temps-réels basées autour d'UML. \`A cette
fin, ils utilisent le système de profils pour étendre l'UML avec leurs
propres artefacts au but de définir les concepts temps-réels et haute
intégrité.

Le Hierarchical Object Oriented Design
methodologie~\cite{vielcanet@wadas89} était une technique de
conception développée par l'industrie aérospatiale pour l'Agence
Spatiale d'Europe. Sa version prochaine, ciblée au système
temps-réels, est HRT-HOOD (Hard Real-Time HOOD)~\cite{burns@rts94},
qui contient des artefacts spécifiques à l'analyse d'ordonnancement et
de sûreté. HRT-HOOD, et son cousin, HRT-UML, qui est un profil UML à
représenter HRT-HOOD, contient des artefacts comme ``t\^aches
cyclique'', ``t\^aches sporadique'' etc. Chacun comportant des
``propriétés'' pertinentes en forme de données de classe comme période
et priorité.

Le profil MARTE (Modeling and Analysis Real-Time and Embedded systems)
est un standard d'OMG~\cite{omg-marte}. Les mécanismes similaire à
HRT-HOOD sont utilisés à décrire les aspects temps-réels du système:
le stéréotype est employé de manière répandu pour décoré les classes
avec la sémantique, une sémantique qui se mène à être parsée par
d'outils. Ce profil contient aussi de la notation pour QdS (Qualité de
Service) ainsi que pour la fiabilité~\cite{bernardi@wosp07}. Il y a
aussi une proposition d'utiliser MARTE comme un mécanisme de
modélisation en AADL---le langage d'architecture discuter dans cette
thèse---en créant une correspondance de MARTE à
AADL~\cite{gerard@iceccs07}.

\section*{Ada Ravenscar}
Ada et son ``runtime'' ou exécutif contient un nombre important de
primitifs de t\^aches et de communication entre t\^aches comme membre
d'ordre premier du langage. En comparaison, l'approche adopté par
d'autres langages est d'utiliser les APIs pour s'appuyer sur le
système d'exploitation en dessous pour ces primitifs; comme exemple,
l'API POSIX qui dote C et C++ avec les t\^aches, les mutexes et les
sémaphores. Cette promotion d'artefacts de runtime à Ada a d'avantages
importants, ainsi que les désavantages; l'avantage principale étant la
portabilité et la capacité d'analyser les programmes au niveau de
compilateur afin de trouver de problèmes d'ordonnancements etc.

Ada a eu plusieurs versions; Ada 83, Ada 95 et finalement Ada 2005, le
langage considéré dans cette thèse. Afin d'éviter les primitifs
non-déterministe d'Ada, comme le rendez-vous, et la manque
d'implémentation d'artefacts temps-réels comme des t\^aches dans Ada
83, les industrielles utilisaient les primitifs de t\^aches et de
communication inter-t\^aches fournis par le système d'exploitation. Le
Profil Ravenscar~\cite{burns@adalett99} pour Ada a été proposé en 1999
et adoptés en 2004~\cite{burns@adalett04}. Ravenscar est une
restriction aux primitifs de t\^aches d'Ada 95 et d'Ada 2005 à un
sous-ensemble garantissant l'ordonnançabilité temps-réels et la
sûreté. Avec Ada 2005, le Profil Ravenscar fait parti du
standard~\cite{arm05}. Le Profil Ravenscar impose un ensemble de
restrictions, les plus importantes étant les suivantes:

\begin{itemize}
\item{La création de t\^aches dynamique est interdite, toutes les
  t\^aches du système doivent \^etres déclarées de manière
  statique. Les t\^aches hiérarchiques sont aussi interdites;}
\item{Les t\^aches ne peuvent pas se terminer. Les t\^aches
  temps-réels sont normalement du type ``boucle infini''; cette
  restriction, avec celle qui interdit la création des t\^aches,
  garantit un ensemble de t\^aches fixe pendant la vie du système;}
\item{Les t\^aches ne peuvent pas changer leurs priorités, qui sont
  définis dans le code du manière statique;}
\item{Les objets de synchronisation doivent \^etre au niveau globale;}
\item{La création dynamique d'objets---avec d'allocateurs---est
  interdite;}
\item{Le primitif de rendez-vous---un type de variable
  conditionnelle---est interdit;}
\item{Le contrôle asynchrone est interdit: des t\^aches ne peuvent pas
  suspendre et ne peuvent pas reprendre l'exécution d'autres
  t\^aches;}
\item{Les objets protégés---objets de synchronisation---doivent
  suivre le protocole de plafond de priorité~\cite{sha@toc90};}
\item{Utilisation d'un ordonnanceur à priorités fixe, avec
  préemption en fonction de priorité et tournoi à la ronde sous
  la même bande de priorités.}
\end{itemize}

Le but principale, qui est l'ordonnançabilité---et son analyse---ainsi
que la sûreté d'exécution déterministe, peut \^etre garantit avec ces
restrictions. Surtout, nous pouvons faire l'analyse d'ordonnançabilité
d'ensemble de t\^aches d'un système Ravenscar avec la technique de
Response Time Analysis~\cite{burns-rtspl} (pages 475---479). Un
deuxième avantage est l'absence des deadlock, grâce au protocole de
plafond de priorité.

Ici, nous donnerons un exemple de création de t\^ache avec Ada
Ravenscar. Les types de t\^aches les plus importantes pour les
systèmes temps-réels sont les t\^aches périodiques et les t\^aches
sporadiques. Nous définissons les deux avec des primitifs d'Ada. Le
code dans Listing~\ref{lst:one_periodic_task_fr} définit une t\^ache
périodique à période de 20ms. L'implémention s'appuie sur le primitif
de \kw{delay until}. Nous pouvons constater que la responsabilité
d'assurer que la t\^ache soit périodique est au programmateur, et la
nature périodique de la t\^ache est évidente dans la structure du code
sur les lignes 8, 11 et 12.

\begin{minipage}{\listingwidth}
\lstset{language=ada,
  numbers=left,
  numberstyle=\tiny
}
\begin{lstlisting}[firstnumber=1, label=lst:one_periodic_task_fr,
    caption=Une t\^ache périodique Ravenscar avec un période de
    20ms]
task Task_A is 
  pragma Priority (240);
endTask_A;

task body Task_A is
  Next_Dispatch : Ada.Real_Time.Time;
begin
  Next_Dispatch := Ada.Real_Time.Clock;
  loop
    -- ...Periodic response code for Task_A...
    Next_Dispatched := Next_Dispatch + Ada.Real_Time.Microseconds (20);
    delay until Next_Dispatch
  end loop;
end Task_A;
\end{lstlisting}
\end{minipage}

Les t\^aches sporadiques sont celles qui ne s'activent pas aux moments
prédéterminées, mais en conséquence d'évènements reçus par le
système. Ces évènements peuvent êtres le résultat d'un interrupt ou
bien envoyé par une autre t\^ache. La propriété intéressante d'une
t\^ache sporadique qui la rend utile est qu'elle garantit un laps du
temps minimale entre deux activations. C'est-à-dire, les t\^aches
sporadiques ne surcharge pas un système aux moments de rafale
d'évènements. Listing~\ref{lst:sporadic_fr} montre la squelette d'une
t\^ache sporadique en Ada Ravenscar.

\begin{minipage}{\listingwidth}
\lstset{language=ada,
  numbers=left,
  numberstyle=\tiny
}
\begin{lstlisting}[label=lst:sporadic_fr, caption=Une t\^ache sporadique en Ada Ravenscar]
task type Sporadic(
   Priority_P : System.Any_Priority;
   Min_Separation_P : Ada.Real_Time.Time_Span
   ) is pragma Priority(Priority_P);
end Sporadic;

task Sporadic is
   Min_Separation : Ada.Real_Time.Time_Span;
   Next_Dispatch : Ada.Real_Time.Time;
begin
   Min_Separation := Min_Separation_P;
   loop
      Event_Object.Await;
      Next_Dispatch := Ada.Real_Time.Clock + Min_Separation;
      -- ... Non-suspending sporadic response code ...
      delay until Next_Dispatch;
   end loop;
end Sporadic;
\end{lstlisting}
\end{minipage}

Pour la communication inter-t\^ache, Ada fournit les objets
protégés. Ceux sont similaires aux objets synchronisés en Java,
c'est-à-dire, seule une t\^ache peut entrer dans les fonctions ou les
procédures de l'objet en simultanément. La fonctionnalité de ``data
port'' peut \^etre implémentée en encapsulant un instance ou un tampon
de type requis comme membre d'objet. Les procédures et les fonctions
d'accès à ces donnés garantirons l'absence de conditions de course
entre t\^aches. Pour implémenter l'échange d'évènements entre
t\^aches, Ada nous fournis l'artefact de ``entry'' sur les objets
protégés, soit une variable conditionnelle. Simplement, une t\^ache
peut attendre sur l'entrée, et une t\^ache peut la déclencher en
appelant une procédure de l'objet protégé qui signale l'entrée.

L'analyse principale qui peut être effectuée sur un système conforme
au Ravenscar est celle d'ordonnançabilité. Comme indiqué précédemment,
le Profil Ravenscar prévoit l'utilisation d'un ordonnanceur de
priorité fixe avec tournoi à la ronde sous la même bande de priorité,
que nous appelons ``Fixed Priority Preemptive Scheduler'' ou FPPS. En
supposant que toutes les tâches sont périodiques, indépendantes (pas
de communication inter-tâches ni de synchronisation) et d\^ures (pas
de délais non respectées), puis l'affectation de priorités selon
l'affectation monotone à période, ou ``Rate Monotonic Assignment'',
résultera à un ordonnancement faisable si l'un est possible sous un
ordonnanceur FPPS~\cite{liu@jacm73}. Le RMA stipule que les t\^aches
d'un système seront affectuées leurs priorités en ordre inverse de
leurs périodes; c'est-à-dire, la t\^ache la plus prioritaire du
système serait celle avec la moindre période.

Hors, le plupart de systèmes temps-réel ont des t\^aches qui doivent
se communiquer. Dans ce cas, il faut prendre en compte le temps
dépenser par des t\^aches bloquées sur d'objets protégés afin de
communiquer avec d'autres. Car les t\^aches accèdantes aux objets
protégés auront la priorité de plafond, il est possible d'analyser la
faisabilité d'ensemble de t\^aches en utilisant
Eq.~\ref{eq:rma_w_sync}. Le temps de bloquage maximale de chaque
t\^ache peut être calculé avec l'équation ci-dessous:

\begin{displaymath}
B_j = \max_{k=1}^{K} \Big(usage(k,j)\times C_k\Big)
\end{displaymath}
\noindent

Si une t\^ache $j$ accède à un objet protégé $k$, $usage(k, j)$ sera
1, sinon 0; et la terme $C_k$ est le temps d'exécution au pire des cas
du procédure ou entrée de l'objet à laquelle $j$ accède, dans ce cas,
$k$.

\section*{Architecture Analysis and Design Language}
Dans cette section, nous donnons une introduction au langage
d'architecture Architecture Analysis and Design Language
(AADL)~\cite{AS5506}. Ce langage, développé par un groupe
d'industriels et d'universités, est ciblé très spécifiquement au
domaine temps-réel distribué et embarqué. C'est un langage basé sur la
notion de composant, qui se communiquent sur des connexions entre
eux. Ici, nous préciserons que ``l'architecture'' d'un système est à
l'échelle plus large que ``la conception'' ou ``design'' au niveau
logiciel de ses composants. Alors, le système sera décrit avec un
langage comme AADL, qui donne la description à l'échelle, et la
conception fonctionnelle des composants pourrais être donnée avec des
moyens auxiliaires, comme discuté ci-dessous.

L'AADL est un langage hiérarchique; les composants composite étant
ceux qui ont de sous-composants, et les composants feuille étant ceux
qui n'en ont pas. Le noyau du langage contient seulement la capacité
de décrire la parti non-fonctionnelle du système, il n'y a aucune
capacité de doter la définition fonctionnelle---soit
algorithmique---aux composants. Alors l'implantation de composants
logiciels peut être donnée en langage de programmation traditionnelle
comme C, C++ ou Java; elle peut même être donnée avec des Statecharts
ou d'autre outil graphique, si une correspondance entre les deux
(interfaçage AADL et Statecharts) est définie.

Un exemple typique serait un composant ``thread'' en AADL, qui
représente une t\^ache. Ce composant a des propriétés comme priorité,
type (périodique, sporadique) ainsi que sa période. De plus, ce
composant aura aussi les définitions d'interface, ce qui le doteront
de la capacité d'interagir avec son environnement. Cette interfaçage
décrit le structure non-fonctionnelle du composant. Une fois définis,
nous utiliserons---par exemple---du code Ada pour fournir le
comportement fonctionnelle à ce
composant. Figure~\ref{fig:comp_code_fr} est la représentation
graphique d'un composant thread. La propriété de période est montrée,
à 40 msec, ainsi que l'interface de quatre ports. Ces ports, qui sont
typé en AADL, se traduisent envers des objets protégés avec procédures
d'accès en Ada, ou en méthodes de mutation et d'accès en C, qui
assurent la s\^ureté de concurrence de t\^aches en utilisant des
mutexes ou des sémaphores.

\begin{figure}
\centering
\includegraphics[scale=0.6]{figs/comp_code}
\caption{Un composant thread en AADL, décris au syntaxe graphique du
  langage, avec deux port d'entrées et de sorties. La t\^ache est
  périodique, avec une période de 40 msec. Veuillez noter que la
  réponse fonctionnelle de la t\^ache est donnée en C}
\label{fig:comp_code_fr}
\end{figure}

Un composant en AADL peut être du type matériel (bus, processeur) ou
logiciel (prototype de fonction, t\^aches, ou type de donnée). Un
composant doit avoir une spécification; il peut aussi optionellement
avoir une ou plusieurs implémentations. L'implémentation d'un
composant complexe pourrais avoir, par exemple, ses sous-composants,
les connexions entre ses sous-composants, ainsi que ses modes
d'opération. L'AADL a sept types de composants, classés en composants
logiciels, composants matériels et composants
hybrides. Table~\ref{tab:comp_cats_fr} fournis un survole de ces types
de composants.

\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Classe} & \textbf{Catégorie} & \textbf{En brèf}\\
\hline
 & Process & Un processus avec mémoire virtuelle et plusieurs t\^aches\\
 & Thread & Unité primitif d'exécution indépendante\\
\textbf{Software} & Thread group & Un groupe de t\^aches\\
 & Data & Un type de données ou instance d'un type\\
 & Subprogram & Un procédure d'un langage de programmation\\
\hline
 & Processor & Microprocesseur avec un ordonnanceur\\
\textbf{Execution platform} & Memory & Stockage de données (RAM, ROM ou disque d\^ur)\\
 & Bus & Un canal de communication au matériel\\
 & Device & Matériel spécialisé avec interface définis\\
\hline
\textbf{Hybrid} & System & Composant hybride pour encapsulé l'architecture du système\\
\hline
\end{tabular}
\caption{Les classes et catégories différentes de composants d'AADL}
\label{tab:comp_cats_fr}
\end{table}

Listing~\ref{lst:props_comps_fr} montre un bout du code AADL qui
définis une interface de t\^ache, une implémentation du t\^ache, ainsi
qu'un composant processus qui en regroupe. L'interface de la t\^ache
montre aussi un port de sorti typé d'un entier. Le port
\texttt{Data\_Out} pourrait \^etre connecté avec un autre \texttt{in
  port} ou \texttt{in out port} du m\^eme type---c'est à dire du type
entier---sur un autre composant. La deuxième chose à remarquer est la
sémantique des propriétés; celle défini sur l'interface (ligne 6) est
préséancée par celle de l'implémentation (ligne 11), et celle-là est
préséancée par celle de la définition (ligne 18).

\begin{minipage}{\listingwidth}
\lstset{language=aadl,
  numbers=left,
  numberstyle=\tiny
}
\begin{lstlisting}[label=lst:props_comps_fr, caption=Interfaces et implémentations de
    composants avec des ports et des propriétés]

thread T1
features
   Data_Out : out data port Ravenscar.Integer;
properties
   Period => 10 ms;
end T1;

thread T1.Impl
properties
   Period => 20 ms
end T1.Impl;

process P
subcomponents
   Thread1 : thread T1;                         -- Période de 10 msec
   Thread2 : thread T1.Impl;                    -- Période de 20 msec
   Thread3 : thread T1.Impl {Period => 30 ms;}; -- Période de 30 msec
end P;
\end{lstlisting}
\end{minipage}

\section*{Génération du code}
Dans cette section, nous décrirons l'une des contributions principale
de cette thèse: la génération du code Ada 2005 conformant au Profil
Ravenscar de la part de modèle AADL. Ceci est une transformation du
modèle, le modèle source étant en AADL, et le modèle cible étant la
syntaxe d'Ada.

L'ingénierie dirigé par des modèles, et la génération du code
automatique est avantageux quelconque soit le langage de programmation
choisi comme cible, mais devient encore plus attirant au cas d'Ada, si
ses primitifs sont utilisés pour créer les t\^aches et les objets
protégés pour la synchronisation. La raison principale étant que---par
exemple---créer une t\^ache en Ada nécessite sa déclaration comme
artefact du code, en comparaison d'un appel à l'RTOS en dessous au cas
du C/C++. Nous avons déjà vu qu'en Ada Ravenscar, la création d'une
t\^ache a besoin d'un squelette. Considérez les
Listings~\ref{lst:api_thread_fr} et~\ref{lst:ada_task_fr}, à gauche,
l'RTOS prendras soin d'assurer qu'une t\^ache à période correcte est
instanciée, et va la réveiller aux instants corrects; à droite, et
comme discuté précédemment, en Ada Ravenscar, nous devons encoder la
caractéristique périodique de la t\^ache nous-mêmes, en utilisant le
primitif de \texttt{delay until}. Créer ces squelette---ainsi que ceux
d'objets protégés---à la main pour un système complexe risque
d'introduire des bugs.

\begin{minipage}{0.40\linewidth}
\lstset{language=c}
\begin{lstlisting}[label=lst:api_thread_fr, caption = Un API d'RTOS pour créer une t\^ache périodique]
_rtos_create_periodic_thread(
   priority, 
   period,
   stack_size, 
   &response
);

void response (void *data)
{
   /* Periodic response code here */
}
\end{lstlisting}
\end{minipage}
\hspace{8mm}
\begin{minipage}{0.50\linewidth}
\lstset{language=ada}
\begin{lstlisting}[label=lst:ada_task_fr, caption=Une t\^ache périodique déclarée en Ada Ravenscar]
task body Periodic_Task is
  Period : Ada.Real_Time.Time_Span;
  Next_Dispatch : Ada.Real_Time.Time;
begin
  Next_Dispatch := Ada.Real_Time.Clock;
  loop
    delay until Next_Dispatch;
    -- Periodic response code
    Next_Dispatch := Next_Dispatch + Period;
  end loop;
end Periodic_Task;
\end{lstlisting}
\end{minipage}

\subsection*{Schema des transformations}
En sa totalité, l'ensemble de t\^aches et d'objets protégés dans un
système constitue le ``framework d'exécution''. Ce framework assure
les propriétés non-fonctionnelle du système, comme le respect de
délais de t\^aches, et les connexions entre t\^aches. Les propriétés
fonctionnelle du système, c'est-à-dire, celles qui repondent aux
besoins fonctionnelles, sont implémentées dans les ``trous'' de ce
framework. Dans le cas du Listing~\ref{lst:ada_task_fr}, un de ces
trous se trouve sur la ligne marquée ``\texttt{-- Periodic response
  code}'', la remplacer par du code applicatif répondant aux besoin
fonctionnelle du système sera l'objectif.

Dans le cadre de ce travail, nous avons développé une
correspondance---soit mapping---entre AADL et Ada Ravenscar. De plus,
nous avons développé l'outillage pour convertir des modèles AADL
automatiquement au code Ada Ravenscar en fonction de ce mapping. Le
noyau conformant à Ada Ravenscar que nous avons choisi est l'Open
Ravenscar Kernel (ORK)~\cite{puente@ae00}; hors, grâce à la
portabilité d'Ada, le code généré pourrait s'exécuter sur d'autres
noyaux conformants au standard Ravenscar. Ceci dit, nous n'avons pas
testé cette hypothèse. Le mapping est le suivant pour les différents
types de composants AADL:

\begin{description}
\item[Processus:]{Transformé en unité de compilation d'Ada;}
\item[T\^ache périodique:]{Transformée en t\^ache Ada avec des
  propriétés pertinentes comme sa période et la taille de sa pile
  transformées en code;}
\item[T\^ache sporadique:]{Transformée en t\^ache Ada avec des
  propriétés pertinentes, ainsi que la mise en application de temps
  minimale entre arrivés d'évènements. Un objet protégé que nous
  appelons un \emph{synchroniseur} est aussi généré sur lequel se
  bloque cette t\^ache en attente de déclenchement;}
\item[Data port:]{Transformé en objet protégé du même type que
  le port, et les procédures \texttt{Get} et \texttt{Set} d'accès
  aux données. Nous appelons ce type d'objet protégé un
  \emph{echangeur};}
\item[Event (data) port:]{Transformé à un type dans
  l'énumération d'évènements que sa t\^ache peut recevoir, au
  cas de port d'entrée; et dans une procédure qui met son type
  d'évènement dans le synchroniseur de la t\^ache cible au cas de
  port de sorti;}
\item[Data component:]{Transformé à un type Ada;}
\item[Data subcomponent:]{Transformé à soit un objet protégé,
  soit un paquetage Ada avec un instance de données privés du type
  indiqué. L'objet protégé est généré si le contrôle de
  concurrence est requis, sinon le paquetage est généré.}
\end{description}

Afin de valider les règles de génération du code, nous avons développé
un plugin Eclipse qui les implémente. Le plugin, nommé ARC (AADL à
Ravenscar Convertisseur), est basé sur l'outil OSATE
AADL~\cite{sei-osate} pour parser les modèles AADL. ARC ne convertit
pas les modèles AADL directement en code Ada, mais les traduit d'abord
envers un modèle intermédiaire basé sur le Ravenscar Méta-Modèle
(RMM), que nous avons développé. Les avantages de cette approche sont:
premièrement, la facilité de traduction, car AADL est un langage
complexe, le traverser et le traduire directement à Ada aurait été
très complexe; et deuxièmement, écrire un générateur du code envers un
autre langage conforme au Ravenscar est beaucoup plus facile, il
s'agit simplement d'écrire un traversale et traduction du RMM vers le
nouveau langage. Ici, il faut noter que l'AADL est beaucoup plus
expressif qu'Ada Ravenscar, donc il est possible de décrire des
systèmes en AADL que l'on ne pourrait jamais traduire à Ada Ravenscar
correctement. Pour respecter les contraintes du Profil Ravenscar, ARC
fait d'abord une vérification du modèle AADL selon un ensemble de
contraintes défini en Object Constraint Language (OCL)~\cite{ocl}. Les
exemples des contraintes sont:

\begin{itemize}
\item{Chaque t\^ache doit \^etre périodique ou sporadique;}
\item{Le délai d'une t\^ache doit \^etre moins que sa période;}
\item{Chaque implémentation de processus doit avoir au moins une t\^ache;}
\item{Chaque t\^ache sporadique doit avoir au moins un \texttt{in event port};}
\end{itemize}

Au cas ou il y a des incohérences dans le modèle AADL, cette
incohérence est annotée, un genre d'erreur sur le modèle
lui-même. Figure~\ref{fig:arc_process_fr} montre les étapes
importantes dans la transformation d'un modèle AADL vers code Ada avec
le plugin ARC.

\begin{figure}
\centering \includegraphics[scale=0.6]{figs/ARC_process}
\caption{Une vue d'ensemble d'outillage ARC}
\label{fig:arc_process_fr}
\end{figure}

\subsection*{Transformations de composants data}
Tous les composants de type data qui sont rencontrés doivent êtres
transformé aux types Ada. Le traducteur peut les rencontrer
directement comme sous-composant d'un autre composant ou ils peuvent
\^etre les types de ``data ports''. Un type ``primitif'' est celui que
nous pouvons traduire directement à un type natif d'Ada (Integer, Boolean
ou Character). Par contre, un type composé est celui qui contient des
sous-composants au niveau de définition en AADL, ce type de composant
doit \^etre transformé à Ada comme un type \texttt{record}, soit un
type structuré, dont les champs correspondent aux sous-composants du
composant AADL. Finalement, les composants data peuvent \^etres
scalaires ou vecteurs.

La détermination qu'un type soit primitif ou composé est fait en
analysant ses implémentations, s'ils en existent. Si une
implémentation existe, et elle a de sous-composants, le type en
question est composé, sinon, il est primitif. Si la propriété
\texttt{Length} est défini sur le type, et si elle a une valeur
différente que 1, le type est un vecteur, sinon il est scalaire. Pour
les types primitifs, leurs propriété \texttt{Data\_Type} est
l'énumération de \texttt{\{Integer, Boolean, Character\}} et donne le
type Ada correspondant. Listing~\ref{lst:primitive_type_ada_fr} montre
les exemples de types primitifs en AADL et leurs transformations à Ada
fait par ARC.

Dans la spécification AADL, le \emph{type} de composant donné
\texttt{Int\_Type} et \texttt{Int\_Vector} n'ont pas
d'implémentations. Hors ces types se trouvent \^etres suffisants
gr\^ace à propriété \texttt{Data\_Type} au cas de \texttt{Int\_Type}
et gr\^ace aux propriétés \texttt{Data\_Type} et \texttt{Length} au
cas de \texttt{Int\_Vector}.

Un type AADL qui n'a qu'un \emph{type} est nommé comme tel en Ada;
donc le type AADL \texttt{Int\_Type} devient \texttt{Int\_Type} en
Ada. Pour les composants AADL qui ont d'implémentations, le type en
Ada devient \texttt{<type>\_<implementation>}, donc le type AADL
\texttt{Bool\_Type.Impl} devient \texttt{Bool\_Type\_Impl} en Ada.

\begin{minipage}{0.45\linewidth}
\lstset{language=aadl}
\begin{lstlisting}[label=lst:primitive_type_aadl_fr, caption=Les types primitifs en AADL]
data Int_Type
properties
  Ravenscar::Data_Type => Integer;
end Int_Type;

data Int_Vector
properties
  Ravenscar::Data_Type => Integer;
  Ravenscar::Length => 10;
end Int_Vector;

data Bool_Type
end Bool_Type;

data implementation Bool_Type.Impl
properties
  Ravenscar::Data_Type => Boolean;
end Bool_Type.Impl;

data Bool_Vector
end Bool_Vector;

data implementation Bool_Vector.Impl
properties
  Ravenscar::Element_Type 
    => data Bool_Type.Impl;
  Ravenscar::Length => 10;
end Bool_Vector.Impl;
\end{lstlisting}
\end{minipage}
\hspace{5mm}
\begin{minipage}{0.45\linewidth}
\lstset{language=ada}
\begin{lstlisting}[label=lst:primitive_type_ada_fr, caption=Les types transformés à Ada]
-- Int_Type data component --
type Int_Type is new Integer;






-- Int_Vector data component --
type Int_Vector is array (1 .. 10)
  of Integer;






-- Bool_Type.Impl data component --
type Bool_Type_Impl is new Boolean;






-- Bool_Vector.Impl data component --
type Bool_Vector_Impl is array (1 .. 10) 
                      of Bool_Type_Impl;
\end{lstlisting}
\end{minipage}

\subsection*{Transformations de composants threads}
\label{sec:fr_transforms}
Un thread périodique en AADL est tout simplement un sous-composant
thread d'un processus avec la propriété \texttt{Dispatch\_Protocol =>
  Periodic}. Les propriétés auxiliaires comme \texttt{Stack\_Size} and
\texttt{Period} sont aussi nécessaires à dimensionner correctement un
thread périodique. La propriété \texttt{Deadline} est optionnelle et
est utilisée en calcul de ``deadline monotonic analysis'' pour
attribuer les priorités. Au cas ou \texttt{Deadline} n'est pas
fournis, le générateur du code attribue la priorité en fonction de
période, selon le protocole RMS. Le code fonctionnel à exécuter est
donné comme propriété \texttt{Compute\_Entrypoint}, ce qui est le nom
de la procédure que la t\^ache Ada doit appeler à chaque invocation.

Nous avons développer une bibliothèque de paquetage Ada
générique\footnote{Un paquetage générique en Ada correspond fortement
  aux classes templatisées du C++} afin de réduire le code généré,
nommé \texttt{ravenscar\_lib}. Cette bibliothèque est disponible en
ligne\footnote{Disponible à \url{http://aadl.enst.fr/arc/}}. L'un de
paquetages génériques fournis s'appelle \texttt{Ravenscar\_Periodic},
qui contient le squelette d'une t\^ache périodique en Ada, dont le
code source est montré en
Listing~\ref{lst:ravenscar_periodic_fr}. Veuillez noter que les
discriminants du paquetages Ada correspondent fortement aux propriétés
AADL du thread, tel que \texttt{Period\_P}, \texttt{Deadline\_P} et
\texttt{Stack\_Size\_P}. La façon dont c'est utilisé par le générateur
du code se trouve dans les Listings~\ref{lst:aadl_periodic_fr}
et~\ref{lst:ada_periodic_fr}.

\begin{minipage}{\listingwidth}
\flushleft
\lstset{language=ada}
\begin{lstlisting}[label=lst:ravenscar_periodic_fr, caption=La spécification de type générique de la t\^ache périodique \texttt{Ravenscar\_Periodic}]
generic
  Period_P : Ada.Real_Time.Time_Span;
  Deadline_P : Ada.Real_Time.Time_Span;
  Priority_P : System.Any_Priority;
  Stack_Size_P : Natural;
  with procedure Dispatch;
package Ravenscar_Periodic is
  task Task_Instance is
    pragma Priority (Priority_P);
    pragma Storage_Size (Stack_Size_P);
  end Task_Instance;
end Ravenscar_Periodic;
\end{lstlisting}
\end{minipage}

\begin{minipage}{0.45\linewidth}
\lstset{language=aadl}
\begin{lstlisting}[label=lst:aadl_periodic_fr, caption=Un thread périodique décrit en AADL]
thread implementation Sensor_Sim_T.RS
properties
  Period => 20 Ms;
  Source_Stack_Size => 4096 B;
  Compute_Entrypoint => "On_Sensor_Sim";
  Dispatch_Protocol => Periodic;
  Deadline => 15 Ms;
end Sensor_Sim_T.RS;





process implementation Partition.Impl
subcomponents
  Sensor_Sim : thread Sensor_Sim_T.RS;
end Partition.Impl;
\end{lstlisting}
\end{minipage}
\hspace{5mm}
\begin{minipage}{0.45\linewidth}
\lstset{language=ada}
\begin{lstlisting}[label=lst:ada_periodic_fr, caption=Un thread périodique transformé en t\^ache Ada Ravenscar]
-- The following code instantiates the
-- generic package that will result
-- in a periodic task

package Sensor_Sim is new 
  Ravenscar_Periodic (
    Period_P
      => Ada.Real_Time.Milliseconds(20),
    Deadline_P
      => Ada.Real_Time.Milliseconds(15),
    Priority_P
      => 239,  
    Stack_Size_P
      => 4096, 
    Dispatch
      => Dispatcher.Sensor_Sim_Dispatcher
);
\end{lstlisting}
\end{minipage}

Un thread sporadique en AADL est un sous-composant thread d'un
processus avec la propriété \texttt{Dispatch\_Protocol =>
  Sporadic}. Les propriétés \texttt{Stack\_Size} et \texttt{Period}
sont utilisé à le dimensionner comme pour les threads périodiques, où
la période est considéré le temps de séparation minimale entre les
évènements déclenchants de la tàche. Au contraire à un thread
périodique, un thread sporadique n'a pas un seul comportement. En
fait, sa comportement dépend complètement du type d'évènement qui
vient de le lancer. Alors, pour un thread sporadique, la propriété
\texttt{Compute\_Entrypoint} n'a pas de la valeur sémantique, à sa
place, chaque event port entrant doit définir sa propre
\texttt{Compute\_Entrypoint}, qui est appelé par le framework en
réception de l'évènement approprié.

Comme pour le thread périodique, nous avons définis un paquetage pour
les threads sporadiques dans la bibliothèque
\texttt{ravenscar\_lib}. Le paquetage \texttt{Ravenscar\_Sporadic}
réduit l'effort de créer des t\^aches sporadiques. La manière dont
c'est utilisé par le générateur du code se trouve dans les
Listings~\ref{lst:sporadic_aadl_fr}
et~\ref{lst:sporadic_instantiation_fr}.

\begin{minipage}{0.45\linewidth}
\lstset{language=aadl}
\begin{lstlisting}[label=lst:sporadic_aadl_fr, caption=Thread sporadique en AADL]
thread Sporadic_Thread
properties
  Dispatch_Protocol => Sporadic;
  Period => 40 ms;
  Stack_Size => 16384b;
end Sporadic_Thread;

...

process implementation P.Impl
subcomponents
  Thr_Name : thread Sporadic_Thread;
end P.Impl;
\end{lstlisting}
\end{minipage}
\hspace{5mm}
\begin{minipage}{0.45\linewidth}
\lstset{language=ada}
\begin{lstlisting}[label=lst:sporadic_instantiation_fr, caption=Thread transformé en t\^ache Ada]


-- Instantiates the generic --
-- package that will result --
-- in a sporadic task       --

package Thr_Name is new
  Ravenscar_Sporadic (
    Priority_P => 240, 
    Stack_Size_P => 16384,
    Dispatch
      => Dispatchers.Thr_Name_Dispatcher
  );
\end{lstlisting}
\end{minipage}

Correspondant à chaque \emph{type} de composant thread sporadique est
généré de nombreuse entités afin de garantir la séparation minimale
d'arrivées d'évènements, les fonctions squelettes de le déclencher
ainsi qu'un objet protégé de type synchroniseur sur lequel ce thread
se bloque en attendant son déclenchement. Le générateur produit aussi
une type d'énumération, qui est utilisée à déterminer le type
d'évènement déclenchant, ce type énumère chaque \texttt{in event
  port}, \texttt{in out event port}, \texttt{in event data port} et
\texttt{in out event data port} attaché aux features du thread.

Aussi généré pour chaque type de thread est un type d'objet protégé
que nous appelons un synchroniseur et auquel nous avons déjà fait
référence. Cet objet protégé à une entrée (déclencheur à variable
conditionnel) et autant de procédures que les event ports de la tâche
pour laquelle il est généré. Afin de discriminer entres les évènements
déclenchants, le générateur émet une énumération avec une étiquette
nommé à chaque \texttt{event port} et \texttt{event data port}
entrant (\texttt{in} ou \texttt{in out}) ainsi qu'une file d'attente
de cette énumération qui représente les évènements reçus. Si
l'interface du thread contient un \texttt{in event data port} ou un
\texttt{in out event data port}, il faudra aussi entreposer les
données associés; pour ce stockage, ARC génère une file d'attente
correspondante à chacun de ses ports entrants.

La t\^ache est déclenchée par l'exécutif d'Ada s'il y a au moins un
évènement dans une des files d'attente de l'objet, et ça car la
conditionne de déclenchement est écrite comme telle par le générateur
du code. Un exemple d'un thread sporadique avec un \texttt{in event
  port} et deux \texttt{in event data port} est montré dans la
Figure~\ref{fig:synchronizer_fr}. Pour cet exemple, l'énumération
\texttt{TType\_Event\_Type} est générée. La conception visuelle du
synchroniseur se trouve à droite dans la figure, dans laquelle nous
constatons la file d'attente globale d'évènements, ainsi que les files
d'attentes \texttt{Evt2\_Queue} et \texttt{Evt3\_Queue} pour
l'entrepôt des données de ces deux data ports. Le code source généré
pour \texttt{Await\_Event} du synchroniseur de ce type de thread se
trouve dans Listing~\ref{lst:await_event_fr}.

\begin{figure}
\centering
\includegraphics[scale=1.4]{figs/synchronizer}
\caption{Synchroniseur d'un thread sporadique nommé \texttt{Thr1} du type \texttt{TType}}
\label{fig:synchronizer_fr}
\end{figure}

\begin{minipage}{\listingwidth}
\begin{lstlisting}[language=ada,label=lst:await_event_fr, caption=L'entrée Await\_Event du synchroniseur TType]
protected body TType_Synchronizer is
...
  entry Await_Event (The_Event    : out TType_Event_Type; 
                     Release_Time : out Ada.Real_Time.Time) when Event_Present is
  begin
    Release_Time := Ada.Real_Time.Clock;  -- Store release time --
    The_Event := Event_Type_Queue (Head); -- Take event from head of event queue --
    Head := (Head+1) mod 9;               -- Update queue --
    Event_Present := Head /= Tail;        -- True if queue not empty --
  end Await_Event;
end TType_Synchronizer;
\end{lstlisting}
\end{minipage}

Correspondant à chaque instanciation du thread, un instance du type
synchroniseur décrit ci-dessus est généré, dont la priorité de plafond
est met au maximum des priorités de tous les threads qui peuvent y
faire accès---tous les threads du système qui peuvent y envoyer des
événements---selon l'information très évidente en fonction de
topologie de connexions AADL dans le modèle. Une procédure globale est
générée correspondante à chaque instanciation du thread sporadique,
nommée \texttt{<Thread\_Name>\_Dispatcher}, celle qui est appelée en
boucle infini par ce thread en attente d'évènement déclenchants. Cette
procédure assure aussi la séparation temporelle minimale entre
l'arrivée d'évènements.

\begin{figure}
\centering
\includegraphics{figs/eventports}
\caption{Spécification de synchroniseur, son instanciation et la
  fonction de déclenchement pour un thread sporadique}
\label{fig:dispatcher_fr}
\end{figure}

Le travail présenté ici a été publié dans le journal de NASA
\emph{Innovations in Systems and Software Engineering} dans
l'édition d'avril 2008.

\section*{Communication déterministe}
Les systèmes d'automatiques pour les véhicules sont parmi les plus
critiques m\^eme dans le domaine du temps-réel. Il y a des standards
très stricts de certification comme le DO-178B pour les systèmes
avioniques. Ces systèmes d'automatique sont implémentés en forme de
``loi du contr\^ole'', qui sont les fonctions de réponse aux données
fournis par les capteurs. Les lois du contr\^ole sont exécutés à
chaque invocation de la t\^ache qui contient son code, un concept que
nous appelons le ``boucle du contr\^ole''. Pour garder stable le
plate-forme dont le système s'occupe, il faut exécuter ce boucle très
fréquemment. De plus, il faut avoir le déterminisme dans les résultats
produits par les composants du systèmes.

La contrainte de résultat déterministe---deux exécutions avec les
m\^emes données d'entrées doivent produire exactement les m\^emes
réponses---peut \^etre respecter en utilisant un langage synchrone
comme Lustre~\cite{halbwachs@ieee91} ou Simulink~\cite{simulink}. Dans
ce paradigme, comme il n'y a qu'une t\^ache, la fonctionnalité totale
du système est implémenté dedans. Gr\^ace au fait que toute est
exécuté en intercalage, la déterminisme est garanti. Hors, avec un
exécutif asynchrone comme un RTOS, une application multi-t\^ache peut
être crées. Dans ce cas les t\^aches peuvent êtres préemptées et
résumées au moments aléatoires en fonction d'arrivés d'évènements, ce
qui introduiras de l'indéterminisme dans le système. L'avantage
d'approche asynchrone est l'utilisation plus efficace du processeur,
ainsi que la capacité de réagir quasi-immédiatement aux évènements
environnementale avec des t\^aches sporadiques.

Une instance de l'indéterminisme dont nous avons parlé se présente
dans la partie gauche de la Figure~\ref{fig:det_non_det_fr}. La
``t\^ache rapide'', \ts, a trois invocations pour chacune de la
``t\^ache lente'', \tl. Si les données les plus frais sont utilisées,
comme à gauche, il risque d'arriver la situation ou deux invocations
des t\^aches auront des données originaires de différentes invocations
de t\^ache producteur. Définissons l'hyperpériode de deux t\^aches
comme le plus petit dénominateur de leurs périodes: dans la première
hyperpériode, $\beta_1$ consomme les données de $\alpha_1$; hors dans
la deuxième hyperpériode, $\beta_2$ consomme celle de $\alpha_5$, au
lieu de celle d'$\alpha_4$. Également, nous voyons que les données
consommées par les instances de t\^ache \ts dépendent fortement sur
l'intercalage et la préemption de la t\^ache \tl, avec les deux
hyperpériodes ayant de différentes instances de données fournis aux
instances $\alpha_i$.

La solution à ce problème que nous avons proposé s'inspire du
monde automatique~\cite{tripakis@emsoft05}, ce qui consiste à
garantir qu'une instance de t\^ache producteur ne transmettra ses
données qu'aux instances des t\^aches consommateurs \emph{de la
  prochaine hyperpériode}. L'hypothèse d'ordonnançabilité d'un
ensemble faisable de t\^aches périodiques et sporadiques garantit
que toutes les instances de toutes les t\^aches finiront dans chaque
hyperpériode du système, ce qui donnera la situation comme celle
montrée à droite dans la Figure~\ref{fig:det_non_det_fr}. Le
générateur du code ARC fournit ce protocole en forme de connecteur
implémenté avec d'objets protégés. Nous avons nommé un
connecteur qui transmet les données d'une t\^ache lente à une
t\^ache rapide \emph{stagger deterministic bridge exchanger}, et
celui dans la diréction opposée \emph{stepper deterministic
  bridge exchanger}. Afin de les décrire au niveau modèle AADL,
nous avons aussi définit des propriétés sur les connexions AADL,
ce qui nous a muni à écrire des système d'automatique
asynchrones.

\begin{figure}
\centering
\includegraphics[scale=1.25]{figs/det_breach_nobreach}
\caption{Gauche: Non-déterminisme dans le flux de données. Droite:
  Protocole déterministe}
\label{fig:det_non_det_fr}
\end{figure}

Le logiciel à haute intégrité comme l'automatique des véhicules---par
éxemple le ``fly-by-wire'' des avions---a des contraintes de
certification très strictes. Le nouveau standard pour le logiciel
avionique, DO-178C, admet la possibilité d'utiliser de la vérification
au lieu d'audit du code dans certains cas. C'est dans ce contexte que
nous avons fourni la génération du code LOTOS (Language of Temporal
Order Specification)~\cite{bolognesi@cnis87} correspondant à un
système AADL. LOTOS est un algèbre de processus basé sur
CCS~\cite{milner-cc} et CSP~\cite{hoare@cacm78} qui a les concepts de
processus qui s'interagissent sur les canaux de communications, ce qui
fait l'analogue assez fiable du Profil Ravenscar. Il faut remarquer
que LOTOS n'est pas un langage de programmation, mais l'un de
modèlisation formelle qui génére un système de transitions étiquetté
(STE). Une fois ARC a généré du LOTOS correspondant au système
AADL---en vue de sa transformation vers Ada Ravenscar---nous pouvons
utiliser la bo\^ite à outils CADP~\cite{garavel@cav07} pour faire
l'exploration d'espace d'états du STE. Les propriétés que l'on vérifie
sur ce STE sont celles d'exactitude des connecteurs déterministe en
présence des t\^aches sporadique---s'il y en a dans la spécification
AADL---quelque soit leurs intercalages de préemption et remise en
exécution. Le travail présenté dans cette section a été publié dans le
\emph{$13^{th}$ International Conference on Embedded and Real-Time
  Computing Systems and Applications, RTCSA 2007}.

\section*{Vers la sémantique formelle}
Dans cette section, nous présenterons une sémantique formelle qui
décrit le comportement du code généré par ARC. L'exercice de
formalisation de sémantique pour un langage de programmation a
plusieurs objectifs, parmi lesquels la documentation précise, la
construction des systémes de preuves et de la vérification, et
l'aide à la programmation gr\^ace à la capacité de raisonnement
que nous est fournit par la description mathématique du
comportement de code.

Certes qu'il y a d'utilité et du pragmatisme dans cette entreprise
de formalisation du langage, hors, il nous faut avouer que la plus
grande valeur de cela reste la joie de découvrir les grands aperçus
de la nature de computation elle-même. Qu'est-ce qu'une computation?
Quelle est sa granularité? Pourrions-nous envisager une unité
atomique de la computation? Peut-être l'introduction de la
sémantique opérationnelle du code Ada Ravenscar pourra répondre à
une partie minuscule de ces questions profondes.

Les sémantiques formelles d'un système quelconque décrirons son
comportement d'une manière précise. Au niveau de langages de
programmation, nous avons trois grands thèmes à donner ces sémantiques
formelles :\\
\begin{description}
\item[Denotationelle :]{Chaque expression ou instruction dans le
  langage de programmation est traduit envers une domaine mathématique
  formelle. Ce domaine décrit le sens ou la signification de chacune
  de ces expressions~\cite{tennent@cacm76};}
\item[Operationelle :]{La sémantique operationelle fournis la
  signification des programmes comme un système de transitions
  étiquetées~\cite{plotkin-sos}. Chaque transition correspond à une
  étape du programme;}
\item[Axiomatique :]{La sémantique d'un programme est donné comme des
  assertions qui se tiennent sur le système avant et après l'exécution
  d'instructions, soi-disant un ensemble de pré-conditions et
  post-conditions pour envelopper les instructions. La sémantique
  axiomatique était introduite par Floyd et Hoare~\cite{floyd@macs67,
    hoare@cacm69}.}
\end{description}

Nous donnons la sémantique formelle dans la forme de sémantique
opérationnelle structurée, ou SOS. L'état du système entier à un
moment donné est le produit Cartésien de l'état de chaque composant,
ce qui est représenté comme un tuple de variables décrivant l'état du
composant. La configuration d'un système pourrais inclure, entres
autres, par exemple:

\begin{itemize}
\item{La durée du temps depuis le démarrage du système;}
\item{La t\^ache en train de s'exécuter;}
\item{La file d'attente des t\^aches pr\^etes à s'exécuter;}
\item{L'ensemble de t\^aches bloquées ou préemptées.}
\end{itemize}

Les transitions différentes correspondantes à un système instancié et
en train de s'exécuter modifiera l'état des paramètres qui décrit
celui-ci selon les règles exprimés par les contraintes du profil
Ravenscar. Il nous faut bien noter que ces sémantiques n'encadre pas
toutes les systèmes que nous pourrions concevoir avec ce profil d'Ada,
mais juste ceux que nous pouvons générer avec le générateur du code
ARC. Afin d'être le plus rigoreux et restrictif possible il nous faut
aussi déclarer que cette génération du code, en produisant seul le
cadre des t\^aches temps-réels et leurs machinerie de la
communication, ne peut pas modéliser mathématiquement le comportement
fonctionnel du code.

\subsection*{L'état de l'art de la sémantique des langages de programmation}
Le travail pertinent et courant dans ce domaine, spécifiquement en
relation avec du temps-réel ainsi que sa liaison avec les langages de
conception des systèmes inclue principalement le standard AADL
soi-même~\cite{AS5506}, celui-ci qui donne la sémantique des t\^aches
en forme d'automates hybrides à la
Henzinger~\cite{henzinger@slcs96}. Toutefois il est clair que ces
sémantiques ne s'adressent qu'au comportement temporel de chaque
t\^ache, et ça aussi en isolation par rapport à l'ensemble des
t\^aches et le système d'exploitation. Les auteurs
de~\cite{halbwachs@emsoft07} proposent une méthodologie de simulation
d'un modèle AADL qui le traduit à une représentation d'exécution
synchrone dans le langage Lustre.

Il existe aussi un assortiment de recherche autour l'effort de
formaliser les sémantiques des noyaux temps-réel en générale et des
exécutifs comme Ravenscar en particulier~\cite{fowler@rtss97,
  lundqvist@rtcsa99, vardanega@rts05,
  fidge@amast00}.~\cite{fidge@amast00} définit une extension
temporelle et causale de CCS de Milner~\cite{milner-cc}. Par contre
\cite{peyre@ae07} adopte une approche inverse en présentant la
sémantique d'un sous-ensemble de primitifs de concurrence dans le
langage Ada. Dans ce cas Ada sert plutot comme un langage de
modélisation que celle de l'implémentation.

Le travail détaillé dans~\cite{fowler@rtss97} est peut-\^etre le
plus proche de celui présenté dans cette thèse. La-dedans les
auteurs s'appuient sur le système de preuve PVS~\cite{owre@cade11}
afin de développer un noyau comme Ravenscar ainsi que la preuve de
certaines de ses propriétés. Au contraire~\cite{lundqvist@rtcsa99}
modélise un système comme Ravenscar en utilisant les automates
temporisées implémentées dans la bo\^ite a outil
UPPAAL~\cite{larsen@jsttt97}, ce qui donne un modèle formel d'une
t\^ache Ada et les preuves des propriétés de sûreté sur
l'automate généré.

Finalement,~\cite{vardanega@rts05} fournis une description
détaillée---quoi-qu'informelle---du comportement d'un noyau
Ravenscar. Vour que les auteurs de ceci sont aussi les développeurs de
l'implémentation Open Ravenscar Kernel~\cite{puente@ae00}, ils sont
particulièrement bien placés à donner la description complète des
construction de t\^achage et communication inter-t\^ache. Ils y ont
détaillé le comportement de \kw{delay until}, un appel à un procédure,
fonction ou entrée sur un objet protégé etc.

La sémantique formelle que nous présenterons ici est composée de deux
grands thèmes: les sémantiques statiques et les sémantiques dynamiques
du système. La partie statique fournis les règles des formes
correctes, c'est-à-dire qu'elle spécifie dans le langage de théorie
d'ensemble l'arbre de syntaxe abstraite de tous les systèmes
bien-formés doivent suivre. Un exemple simple d'une telle règle
pourrais être celle qui dit ``à chaque t\^ache sporadique il doit
correspondre strictement un synchroniseur~\footnote{Un synchroniseur,
  comme spécifié avant, est un objet protégé avec une entrée} dont
l'entrée protégée la déclenchera''. L'outil ARC convertis le modèle
AADL en considération à une instance de Ravenscar Meta-Modèle, voir
RMM. Le RMM est une représentation interne du système qui contient
seul les éléments nécessaires à la génération du code Ada conformant à
Ravenscar. Donc la sémantique statique devient les relations entre les
meta-classes de RMM.

Les sémantiques dynamiques sont la deuxième partie que nous
présenterons ici. Celles-là décrivent l'évolution du système avec le
passage du temps en fonction d'évènements reçus de
l'environnement. Les structures de données du noyau sont représentées
en objets mathématiques comme des ensembles, des sacs et des files
d'attentes qui peut êtres manipulées en conséquences de transitions
éffectuée par le modèle. Ces structures de données pourrait être
utilisées comme des pré-conditions aux certaines transitions.

\subsection*{La sémantique statique de Ravenscar Méta-modèle}
Dans cette section nous ferons une exposition détaillée du RMM. Une
instance du RMM représente le modèle d'une application Ravenscar, ce
qui est intuitif quand nous constatons qu'une instanciation d'un
méta-modèle doit forcement être un modèle. Nous définissons un
système Ravenscar d'être composé de cinque ensembles finis et
disjoints des ``composant de computation'', chacun du quels
correspondent à une classe dans l'instanciation du RMM qui représente
ce système. Formellement, les ensembles dont nous parlons sont les
suivants:

\begin{eqnarray}
  \nonumber
  \text{\textbf{T\^aches périodiques}} \ {\cal T}_p \!& \!= \!&\! \{P_1 \ldots P_n\}\\
  \nonumber
  \text{\textbf{T\^aches sporadique}} \  {\cal T}_s  \! & \!= \! & \!  \{S_1  \ldots S_m\} \\
  \nonumber
  \text{\textbf{Interruptes}} \   {\cal U} \! & \!= \! & \! \{U_1  \ldots U_k\}  \\ 
  \nonumber
  \text{\textbf{Synchroniseurs}} \    {\cal D} \! & \!= \! & \! \{D_1 \ldots D_l\} \\  
  \nonumber
  \text{\textbf{Echangeurs}} \  {\cal E} \! & \!= \! & \! \{E_1  \ldots E_r\} 
\end{eqnarray}

Chacun entre ceux-ci sont compris de tous les objets instanciés de la
part de la méta-classe appropriée du RMM, par exemple, ${\cal T}_p$ a
comme membres tous les objets du type \texttt{Periodic} qui se trouve
dans le modèle AADL et qui ont été instanciés en le traversant. Dans
nos discussions nous allons traverser ces ensembles---c'est-à-dire
qu'ils seront indexé---par des symboles comme $P_i$ pour l'ensemble
${\cal T}_p$, $S_i$ pour l'ensemble ${\cal T}_s$, $U_i$ pour
l'ensemble ${\cal U}$, $D_i$ pour l'ensemble ${\cal D}$ et $E_i$ pour
l'ensemble ${\cal E}$.

Aussi défini afin d'aider l'expression brève des règles sont les
quatre ensembles auxiliaires: $\text{\textbf{Tasks}}$ noté ${\cal T}$,
$\text{\textbf{Activities}}$ noté ${\cal A}$, $\text{\textbf{Protected
    objects}}$ noté ${\cal P\!O}$, et finalement
$\text{\textbf{Computational units}}$ noté ${\cal C}$). Leurs
définitions formelles sont à la suite:

\begin{eqnarray}
  {\cal T} & = & {\cal T}_p\cup {\cal T}_s
  \ \ \ \ \ \ \ \ \ \ \: \text{(indexé par} \ T, T', T_i \text{)} \nonumber \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  {\cal A}  & =  & \, {\cal T}_p\cup {\cal T}_s \cup
  {\cal U} \ \ \ \ \ \text{(indexé par} \ \alpha, \alpha',
  \alpha_i \text{)} \nonumber \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  {\cal P\!O} & = & \ \, 
  {\cal E} \cup {\cal D} \ \ \ \ \ \: \ \ \ \ \ \text{(indexé par} \ \pi, \pi',
  \pi_i \nonumber \text{)} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\cal C} & = & {\cal A}
  \cup {\cal P\!O} \ \ \ \ \ \: \ \ \ \ \ \text{(indexé par} \ \gamma, \gamma',
  \gamma_i \text{)} \nonumber
\end{eqnarray}

Nous définissons cinq fonctions sur des différentes composants de
computation de Ravenscar et qui reflètent directement les
méta-attributs de la méta-classe qui y corresponds. Ces fonctions ont
les types suivants:\\
\begin{eqnarray}
  \label{eq:anypriority}
  \text{\scshape priority}: &{\cal C} & \to \ \ 
    {\scriptstyle \mathbb{ANYPRIORITY}} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\scshape holdingtime}: & {\cal T} & \to \ \  
    {\scriptstyle \mathbb{TIME}} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\scshape wcet}: & {\cal A}  &  \to \ \  
    {\scriptstyle \mathbb{TIME}} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\scshape deadline}: & {\cal A}   &  \to  \ \  
    {\scriptstyle \mathbb{TIME}} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\scshape prog}: & {\cal C}  & \to \ \  
    {\scriptstyle \mathbb{PROGS}} 
\end{eqnarray}

$\scriptstyle \mathbb{TIME}$ est un temps discret et il est la domaine
des fonctions $\text{\scshape holdingtime}$, $\text{\scshape wcet}$ et
$\text{\scshape deadline}$. $\text{\scshape WCET}$ donne la durée
d'exécution au pire cas d'une t\^ache ou d'une interrupte en absence
de concurrence pour le CPU et le mémoire. $\text{\scshape
  holdingtime}$ est soit la période (au cas de t\^ache périodique) ou
l'intervalle du temps minimale entre deux déclenchements consécutives
(au cas de t\^ache sporadique). $\scriptstyle \mathbb{PROGS}$ est le
sous-ensemble du code Ada auquel les unités computationelle (t\^aches,
interruptes ou objets protégés) doivent conformées. Le code d'une
unité fonctionnelle $\gamma$ est $\text{\scshape prog}(\gamma)$ et sa
définition est fournis par une grammaire différente pour chaque type
d'unité computationelle. Finalement $\scriptstyle
\mathbb{ANYPRIORITY}$ est une intervalle d'entiers non-négatifs
$\mathbb{N}$ qui donne les priorités possibles du système, et la
fonction $\text{\scshape priority}$ appliquée à une t\^ache donne sa
priorité de base et appliquée à un objet protégé donne sa priorité de
plafond.

${\scriptstyle \mathbb{PROGS}}$ pourrais \^etre définit en tant que
grammaire dont les parties terminales sont \texttt{comp}, une
instruction séquentielle n'ayant pas d'effet sur l'environnement ainsi
que tous les API des constructions Ravenscar générées comme
\texttt{Set(E)} et \texttt{Get(E)} d'échangeurs,
\texttt{Send\_Event(D)} et \texttt{Await\_Event(D, CT)} de
synchroniseurs ainsi que les mots-clés d'Ada comme \texttt{delay
  until} et \texttt{return}. Le terminale \texttt{comp} sert à
abstraire du code fonctionnel. La grammaire des constructions
Ravenscar est la suivante:\\

\begin{tabular}{llll}
\emph{T\^aches périodiques}: 
& BP & := & ${\text{\ttfamily comp}}$ ; BP \\
   & & \ \ \ \ $|$ & ${\text{\ttfamily Set}}(E)$ ; BP  \\
   & & \ \ \ \ $|$ & ${\text{\ttfamily Get}}(E)$ ; BP \\
   & & \ \ \ \ $|$ & ${\text{\ttfamily Send\_Event}}(D)$ ; BP \\
   & & \ \ \ \ $|$ & ${\text{\ttfamily delay until}}$ \\
\\
\emph{T\^aches sporadiques}: & BS &  := & ${\text{\ttfamily Await\_Event}}(D,
CT)$ ; BP\\ 
\\
\emph{Interrupts}: & BU & := & ${\text{\ttfamily Send\_Event}}(D)$
$|$ ${\text{\ttfamily Set}}(E)$\\
\\
\emph{Echangeurs}: & BE &  := & [{\ttfamily Set}$\to$CC, {\ttfamily
  Get}$\to$CC]\\
\\
\emph{Synchroniseurs}: & BD & := & [{\ttfamily Send\_Event}$\to$CC, {\ttfamily Await\_Event} \{CT:=Clock\}$\to$CC] \\ 
\\
&CC &  := & ${\text{\ttfamily comp}}$; CC $|$ ${\text{\ttfamily ret}}$ \\
\end{tabular}\\

Selon cette grammaire nous constatons que le programme d'une
t\^ache périodique \text{\scshape prog}($P$) doit conformer au
non-terminale BP, ce qui veux dire qu'elle peut faire de computation,
écrire et lire des données par le conduit des échangeurs et m\^eme
transmettre d'évènements, mais qu'elle doit à tout prix finit par
\texttt{delay until}, ce qui la fera s'endormir jusqu'à sa prochaine
déclenchement. Également, une t\^ache sporadique doit commencer avec
un appel a son synchroniseur pour attendre son évènement de
déclenchement et de suite se comporte d'une t\^ache périodique.

Une analyse du program \text{\scshape prog} fourniras clairement la
topologie de communication entre les unités de computation du
système. Nous définissons quatre relations topologiques induisent par
\text{\scshape prog}:\\

\begin{eqnarray}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\emph{sets}} & : & \rset \ \subset\  \ {\cal A} \times {\cal
  E} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\emph{gets}} & : & \rget \ \subset \ \ {\cal T} \times {\cal
  E}  \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\emph{sends\_event}} & : &  \rsvt \  \subset \ \ {\cal A}
  \times {\cal D} \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \text{\emph{awaits\_event}} & : &  \rgvt \ \subset \ \ {\cal T}_s
  \times {\cal D}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{eqnarray}

La relation $sets$ est valable pour un tuple de t\^ache et échangeur
si et seulement si la t\^ache écrit à l'échangeur, c'est-à-dire $T_i
\rset E$ implique que $T_i$ appel $E.Set$. Également $get$ signifie
une lecteur depuis l'échangeur, $send\_event$ veux dire que la t\^ache
envoi un événement au synchroniseur et finalement $awaits\_event$
implique que la t\^ache sporadique attends sur l'entrée protégée du
synchroniseur qui fait parti du tuple. Nous pouvons les définir
rigoureusement:

\begin{eqnarray}
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \texttt{Set}( \! E \! ) \in \text{\scshape prog}(\alpha) \!\!\!  
   & \!\!\! \Leftrightarrow \!\!\! & \!\!\! \alpha  \rset E  \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \texttt{Get}(\! E\!)  \in \text{\scshape prog}(T)  \!\!\!
   & \!\!\! \Leftrightarrow \!\!\! & \!\!\! T \rget E  \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \texttt{Send\_Event}(\! D \!) \in \text{\scshape prog}(\alpha) \!\!\! 
   & \!\!\! \Leftrightarrow \!\!\! & \!\!\! \alpha \rsvt D \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \texttt{Await\_Event}(\! D, CT \! ) \in \text{\scshape prog}(S) \!\!\!
   & \!\!\! \Leftrightarrow \!\!\! & \!\!\! S \rgvt D
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{eqnarray}

Trois relations dérivées qui nous aidera à écrire les symantiques
dynamiques sont \emph{dispatches}, l'inverse de \emph{awaits\_event};
\emph{writes\_to}, l'union de \emph{sets} and
\text{\emph{sends\_event}}; et \emph{accesses}, l'union de quatre
relations primitives. Formellement:

\begin{eqnarray}
  D \RL{DIS} S & \Leftrightarrow & S \rgvt D \label{geinvd}\\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \nonumber\\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \alpha \RS{WTO} \pi & \Leftrightarrow & \pi \in {\cal E} \ \wedge \ \alpha \rset \pi\\ 
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \nonumber
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  & \text{ou} & \pi \in {\cal D} \ \wedge \ \alpha \rsvt \pi\\
  \nonumber \\
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \label{eq:accdef_fr}
  \alpha \RL{ACC} \pi & \Leftrightarrow & 
  \pi \in {\cal E} \ \wedge \ \alpha \rset \pi\\
  \nonumber
  & \text{ou} & \pi \in {\cal E} \ \wedge \ \alpha \rget \pi\\ 
  \nonumber 
  & \text{ou} & \alpha \in {\cal A} \ \wedge \ \pi \in {\cal D} \ \wedge \ \alpha \rsvt \pi\\
  \nonumber 
  & \text{ou} & \alpha \in {\cal T}_s \  \wedge \ \pi
  \in {\cal D} \ \wedge \ \alpha \rgvt \pi
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{eqnarray}
 
Comme exemple d'utilisation de la sémantique statique nous décrivons
le protocole de priorité plafond de verrouillage~\cite{sha@toc90} qui
est utilisé par l'exécutif Ravenscar à assurer l'exclusion
mutuelle. Alors la fonction {\scshape priority} doit satisfaire la
propriété suivante (ou $\RL{ACC}$ est la relation \emph{accesses}
définie en équation~\ref{eq:accdef_fr}):

\begin{eqnarray}
  \forall \alpha \in {\cal A} \wedge \forall \pi \in {\cal D}:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
  \nonumber \\
  (\alpha \RL{ACC} \pi) \ \ 
  \Rightarrow \ \  \text{\scshape priority}(\pi) \geq \text{\scshape priority}(\alpha)
\end{eqnarray}

Finalement nous déclarons que les contraintes de la sémantique
statique d'un système Ravenscar bien-formé doit satisfaire les quatre
relations suivantes:

\begin{eqnarray}
\label{totd_fr} \forall \ D, \ \exists  \ S \  \text{unique satisfaisant:} \ D \RL{DIS} S  \\
\label{injd_fr} \forall \ S, \ \exists  \ D \  \text{unique satisfaisant:} \ S \rgvt D \\
\label{totw_fr}\ \forall \ U, \ \exists \ \pi \  \text{unique satisfaisant:} \ U \RL{WTO} \pi \\
\label{injw_fr} \ U \RL{WTO} \pi \ \ \text{et} \  \ U' \RL{WTO} \pi \ \Rightarrow \  \ U=U'
\end{eqnarray}

Un synchroniseur peut déclencher un maximum d'une t\^ache
(\ref{totd_fr}). Correspondant à chaque t\^ache sporadique, il existe
un et un seul synchroniseur qui peut la déclencher
(\ref{injd_fr}). Chaque interrupte écrit à un seul objet protégé
(\ref{totw_fr}). Au maximum une interrupte peut écrire à un objet
protégé (\ref{injw_fr}). L'interprétation des contraints
(\ref{totd_fr}) et (\ref{injd_fr}) signifie que les relations
$\RL{DIS}$ et \rgvt sont bijectives et mutuellement inverses. De plus,
(\ref{totw_fr}) et (\ref{injw_fr}) disent que la relation $\RL{WTO}$,
quand limitée à ${\cal U}$ est une fonction injective avec co-domaine
en ${\cal P\!O}$.

\subsection*{La sémantique dynamique des systèmes Ravenscar}
\label{sec:dynamic_semantics_fr}
La sémantique dynamique du système est représentée dans la forme d'un
tuple, dont l'évolution en fonction du temps et de stimuli externe est
modélisée avec des transitions étiquetées. Le ``contexte d'exécution''
$c$ est l'entité qui possède le CPU à un moment donné. Ici ça peut
\^etre l'ordonnanceur dénoté $\sigma$ ou $\sigma_s$, la t\^ache idle
$\iota$ ou une activité $a$. L'état $\sigma$ d'ordonnanceur est quand
il a pris contrôle, et $\sigma_s$ quand il est prêt à renoncer
contrôle. Par exemple les contextes actifs d'états d'une t\^ache
sporadique sont $S$, $S \rset E$, $S \rsvt D$, $S \rget E$ et $S \rgvt
D$. Ici $\alpha \rx \pi$ correspond au contexte d'exécution de l'objet
protégé $\pi$ en train d'exécuter la procédure $x$ appelé par
$\alpha$. Nous utilisons une notation de record à
la~\cite{cardelli@mfps90} afin de maintenir l'information d'état
d'unités computationelle. Les champs de chaque unité computationelle
sont dénombrés en Table~\ref{tab:fields_fr}. En tant qu'exemple de
mise à jour, constatez que la suivante signifie que le record $D'$ est
le m\^eme que $D$ avec le champ $Bar$ égal à $true$ et $Queue$ égal à
$\epsilon$:

\begin{center}
$D'=
  \langle
    D\gets\SFT{Bar}=\SFT{true}\gets\SFT{Queue}=\epsilon
  \rangle$
\end{center}

\begin{table}
\centering
\begin{tabular}{|l|l|c|c|c|c|c|c|}
\hline
Description de champ & Nom & Type 
& ${\cal D}$ & ${\cal E}$ & ${\cal T}_s$ & ${\cal T}_p$ & ${\cal U}$ \\ 
\hline
Etat courant du program & 
$\SFT{Beh}$ & ${\scriptstyle \mathbb{PROGS}}$
& $\surd$ & $\surd$ & $\surd$ & $\surd$ & $\surd$ \\
\hline
Temps actuelle & 
$\SFT{CT}$ & ${\scriptstyle \mathbb{TIME}}$
& $\surd$ &  &  &  &  \\
\hline
Temps de déclenchement prochaine &
$\SFT{Nd}$ & ${\scriptstyle \mathbb{TIME}}$
&  &  & $\surd$ & $\surd$ &  \\
\hline
Temps écoulé & 
$\SFT{Et}$ & ${\scriptstyle \mathbb{TIME}}$
&  &  & $\surd$ & $\surd$ & $\surd$ \\
\hline
Temps d'exécution & 
$\SFT{Pt}$ & ${\scriptstyle \mathbb{TIME}}$
&  &  & $\surd$ & $\surd$ & $\surd$ \\
\hline
%Time blocked & 
%$\SFT{Tbl}$ & ${\scriptstyle \mathbb{BOOL}}$
%&  &  & $\surd$ & $\surd$ &  \\
%\hline
%Event blocked & 
%$\SFT{Ebl}$ & ${\scriptstyle \mathbb{TIME}}$
%&  &  & $\surd$ &  &  \\
%\hline
File d'attente d'entrée & 
$\SFT{Queue}$ & ${\cal T}_s \cup \{\epsilon\}$
& $\surd$ &  &  &  &  \\
\hline
Etat de barriere & 
$\SFT{Bar}$ & ${\scriptstyle \mathbb{BOOL}}$
& $\surd$ &  &  &  &  \\
\hline
Nombre d'événements & 
$\SFT{Ec}$ & $\mathbb{N}$
& $\surd$ &  &  &  &  \\
\hline
\end{tabular}
\caption{Champs d'unités d'exécutions}
\label{tab:fields_fr}
\end{table}

$R$ est une file d'attente prioritisée d'activités ``prêtes'' qui peut
possiblement être vide. $R$ est ordonné en priorité de t\^ache; ce qui
veux dire qu'à un moment donné l'activité en t\^ete de $R$ est la plus
prioritaire du système. Le tuple d'état du système est:

\begin{equation}
  \text{\small \textit{IL}} \intrupt
  \big\langle c, R, B, \SFT{ns}, \SFT{t} \big\rangle
\end{equation}
\noindent
ou
\begin{itemize}
  \item{$\text{\small \textit{IL}}$: la liste d'interruptes présentes;}
  \item{$c$: le contexte d'exécution;}
  \item{$R$: la file d'attente des t\^aches pr\^etes;}
  \item{$B$: la file d'attente des t\^aches bloquées;} 
  \item{$\text{\sffamily ns}$: le temps d'horloge système ou l'ordonnanceur commencera exécution;}
  \item{\SFT{t}: le temps actuel.}
\end{itemize}

Chaque type de contexte d'exécution peut performer des étapes
d'exécution spécifiques qui change le tuple d'état du système. L'étap
performer par le contexte d'exécution active dépend sur le code
\SFT{Beh} et l'environnement. L'état initial est représenté par
$\langle\sigma, R_0, \{\}, 0, 0\rangle$ ou $R_0$ sont toutes les
t\^aches en ordre de priorité et il n'y a aucune t\^ache bloquée donc
$B_0 = \{\}$. Nous décrivons les transitions selon le prototype
suivant, qui dit que si les \emph{antecedents} évalue à vrai la
transition est prise en exécutant \emph{act} et la conséquente (le
dénominateur) tiens:

\begin{center}
\formatreg{
  \regle{ \textit{Antecedents}}
	{
	  \text{\small  \textit{IL}} \intrupt 
	  \big\langle 
	    c, R, B, \text{\sffamily ns}, \text{\sffamily t} 
	    \big\rangle
	  \Faitv{\textit{act}}
	  \text{\small  \textit{IL'}} \intrupt
	  \big\langle
	    c', R,' B', \text{\sffamily ns'}, 
	    \text{\sffamily t}
	    \big\rangle \sqplus \delta(\textit{\small act})
	} \textit{\scriptsize SURNOM}
}
\end{center}

\textit{IL} et \textit{IL'} sont optionnels. $\delta(act)$ signifie le
temps pris par la transition et $\sqplus\delta(act)$ est l'opérateur
de \emph{vieillissement}:

\begin{displaymath}
  \big\langle c,R,B,\SFT{ns},\SFT{t} \big\rangle
\sqplus \delta (act) = 
\big\langle c \sqplus \delta (act), \, R \sqplus \delta (act), \,
B, \, \text{\sffamily ns}, \, \text{\sffamily t}+\delta (act)\big\rangle
\end{displaymath}

\noindent
ou:
\begin{equation} 
\nonumber
  c\sqplus\delta (act) = \left \{
    \begin{array}{l}
      \sigma\qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad\quad\quad\quad\quad\quad\text{si}
      \ \ c=\sigma \\
      \iota
      \qquad\qquad\qquad\qquad\qquad\qquad\qquad\quad\quad\quad\quad\quad\quad\ \text{si}\ \ c=\iota
      \\
      \langle\alpha\gets\SFT{Et}=\alpha\cdot\SFT{Et}+\delta (act)
      \gets\SFT{Pt}=\alpha\cdot\SFT{Pt}+\delta (act)\ \ \ \text{si}
      \  c=\alpha\vee c=\alpha\rx\pi\rangle     
    \end{array} 
    \right.
\end{equation}

\begin{equation}
\nonumber
  R\sqplus\delta (act) = \left \{
    \begin{array}{l}
      \langle a_1\gets\SFT{Et}=a_1.\SFT{Et}+\delta (act) \rangle \\
      \ \ \ \ \ \ \ \ \ \ \smcirc \\
      \ \ \ \ \ \ \ \ \ \ \vdots \\
      \ \ \ \ \ \ \ \ \ \ \smcirc \\
      \langle a_n\gets\SFT{Et}=a_n.\SFT{Et}+\delta (act) \rangle\
    \end{array}
    \quad\text{si}\ R=a_1\smcirc\ldots\smcirc a_n
    \right.
\end{equation}

Ci-dessus nous disons que l'ordonnanceur et la t\^ache idle ne sont
pas impactés par l'opérateur de vieillissement. De plus que pour le
contexte actif cet opérateur incrément le temps écoulé (\texttt{Et})
et temps de computation (\texttt{Pt}), hors chez les t\^aches prêtes
et bloquées il incrément seul le temps écoulé. Dans la suite nous
donnons quelleques transitions comme exemple. Pour une liste
exhaustive consultez le Chapitre~\ref{chap:formal_sem} de ce
manuscrit.

La transition \emph{IDLE} modèle la t\^ache idle en train de
s'exécuter. L'antécédent exprime que la file d'attente des t\^aches
pr\^etes est vide et nous n'avons pas encore abordé le moment
d'ordonnancement prochain, \SFT{ns}. En conséquence l'âge du système a
incrementé et $\iota$ reste toujours le contexte actif.

\formatreg {
  \regle {
    c=\iota \ \wedge \ \text{\sffamily t} < \text{\sffamily ns} \ \wedge \ R=\{\}
  } {
    \big\langle c,R,B,\SFT{ns},\SFT{t}\big\rangle\ 
    \Faitv{\text{idling}} 
    \ \ \big\langle c,R,B,\SFT{ns},\SFT{t}\big\rangle
    \sqplus\delta(idling)
  }
  \textit{\footnotesize IDLE}
}

La transition \emph{CMPT} modèle une computation séquentielle sans
effet de borde par une t\^ache. Le comportement (\SFT{Beh}) doit avoir
une instruction \texttt{comp} en t\^ete et il faut que le temps soit
avant le moment d'ordonnancement, \SFT{ns}. Il faut noter que
\emph{CMPT} n'incrémente pas seulement l'âge du système mais aussi
avance \SFT{Beh}.

\formatreg {
  \regle {
    c=T \ \wedge\ T\cdot\SFT{Beh}=\SFT{comp};\SFT{C}\ \wedge\ \SFT{t}<\SFT{ns}
  } { 
    \big\langle c,R,B,\SFT{ns},\SFT{t}\big\rangle\ 
    \Faitv{\SFT{comp}} \ 
    \big\langle T',R,B,\SFT{ns},\SFT{t}\big\rangle\sqplus\delta(\SFT{comp})\\ \\
    T'=\langle T\gets\SFT{Beh}=\SFT{C}\rangle
  }
  \textit{\footnotesize CMPT}  
}

La transition \emph{SYCT} modèle l'exécution de la première
instruction d'une t\^ache sporadique. Cette transition capture le
temps actuel dans le paramètre $\SFT{CT}$ pour calculer le temps de
déclenchement prochain par cette t\^ache sporadique.

\formatreg {
  \regle {
    c=S\RL{x}D\ \wedge\ D\cdot\SFT{Beh}=(\SFT{CT:=Clock};\SFT{CC})\ \wedge\ \SFT{t}<\SFT{ns}
  } {
    \big\langle c,R,B,\SFT{ns},\SFT{t}\big\rangle
    \Faitv{\SFT{CT:=Clock}}
    \ \big\langle S\RL{x}D',R,B,\SFT{ns},\SFT{t}\big\rangle \sqplus
    \delta(CT:=Clock)\\ \\
    D'=\langle D\gets\SFT{Beh}=\SFT{CC} \gets \SFT{CT}=\SFT{t} \rangle\\
  }
  \textit{\footnotesize SYCT}
}

La transition \emph{NBCL} représente une activité (t\^ache ou
interrupte) quand il fait appel à une procédure d'un objet
protégé. Gr\^ace au protocole de priorité plafond (PCP) et la règle
\texttt{FIFO\_Within\_Priorities} d'Ada ces procédures sont
non-bloquantes. L'antécédent dit que le comportement courant du
contexte actif est un appel à procédure et il n'est pas encore un
moment d'ordonnancement. La conséquente est que le code d'objet
protégé s'exécute, et ceci à une priorité \SC{priority($\pi$)} par
l'équation de PCP qui dit $\text{{\scshape priority}}(\alpha\RL{x}\pi)
= \text{{\scshape priority}}(\pi)$.

\formatreg {
  \regle {
    c=\alpha\ \wedge\ \alpha\cdot\SFT{Beh}=(x(\pi);C)\ \wedge\ x\in\{\FNT{Get, Set,Send\_Event}\}\ \wedge\ \SFT{t}<\SFT{ns}
  } { 
    \big \langle c,R,B,\SFT{ns},\SFT{t}\big\rangle
    \Faitv{\text{$x$}}
    \big\langle\alpha'\RL{x}\pi,R,B,\SFT{ns},\SFT{t}\big\rangle\sqplus\delta(x)\\ \\
    \alpha'=\langle\alpha\gets\SFT{Beh}=C\rangle\\
    \pi'=\langle\pi\gets\SFT{Beh}=\text{\scshape prog}(\pi ).x\rangle
  }
  \textit{\footnotesize NBCL}  
}

\subsection*{Prochaines étapes de la sémantique formelle d'Ada}
Nous avons présenté la sémantique formelle d'Ada Ravenscar dans cette
section, et il faut noter que celle-là est fixée sur deux axes: elle
est valable pour du code Ada limité au profil Ravenscar et au code
généré par l'outil ARC. Le travail dans l'avenir que nous prévoyons
consiste surtout à utiliser cette sémantique afin de la
\emph{simulation} et de la \emph{vérification} du code généré. Le
travail présenté dans cette section a été publié dans $13^{th}$
\emph{International Conference on Reliable Software
  Technologies---AdaEurope'2008}. 

\section*{Conclusions}
L'ingénierie dirigé par des modèles (IDM) est un mécanisme puissant
pour réduire l'effort et la probabilité de bugs dans le développement
de logiciels. Dans le contexte de cette thèse, nous avons présentée
les approches existantes d'IDM ciblée au domaine de haute intégrité et
temps-réel d\^ur. Il f\^ut apparent que m\^eme s'il y en a plusieurs
qui sont utilisés dans l'industrie, comme SCADE/Lustre, Simulink et
UML, il y a des problèmes qui existent avec chacun de ces approches
par rapport aux systèmes temps-réels complexes. Soit ils sont tr\^op
proche du domaine génie logiciel et manquent les primitifs et la
capacité de décrire les systèmes temps-réel efficacement (voir UML et
ses profils). Soit ils sont tr\^op proches du domaine temps-réel et
n'ont pas l'éxpressivité requise par la génie logiciel (voir
Lustre/SCADE et Simulink) afin de concevoir les systèmes complexes
temps-réels qui peuvent mélanger les t\^aches d'automatique avec
d'autres.

Nous avons choisi une approche de génération du code à partir d'un
langage d'architecture conçu spécifiquement pour le domaine du
temps-réel. Ainsi, nous avons démontrer la faisabilité et l'efficacité
de générer du code Ada Ravenscar à partir des modèles AADL. Le Profil
Ravenscar nous donnant plusieurs garantis sur la sécurité, la
fiabilité et l'ordonnançabilité du système construit avec son
framework.

De plus, nous avons proposé un nouveau primitif de communication
inter-t\^ache afin d'assurer la déterminisme, qui est d'une importance
centrale dans les systèmes automatique. L'intégration dans le
générateur du code de ces primitifs de communication---les connecteurs
déterministes---ainsi que l'automatisation de leurs vérification de
comportement avec l'algèbre de processus LOTOS, fait une b\^oite à
outils pertinent aux systèmes temps-réels asynchrones généralistes.

Finalement, nous avons présenté une sémantique formelle d'Ada
Ravenscar généré par ARC dans le formalisme de sémantique
opérationnelle structurée~\cite{plotkin-sos} (SOS). SOS décrit la
sémantique en transitions d'états d'un système
hypothétique. L'objectif étant de formaliser le comportement totale du
code généré par ARC afin de pouvoir faire des vérifications plus
systémiques que seules les connecteurs déterministes.

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% ispell-dictionary: "fr"
%%% TeX-master: t
%%% End:

%%  LocalWords:  ordinateurisation temps-réels courriél ordinateurisation criticité ciblé préemptif
%%  LocalWords:  ordonnançabilité apériodiques apériodique Simulink
%%  LocalWords:  ordonnanceur ordonnanceurs déboggage méta-modèle
%%  LocalWords:  structurellement encapsulées statecharts portabilité
%%  LocalWords:  Ravenscar l'ordonnançabilité d'ordonnançabilité
%%  LocalWords:  temps-réel
